---
title: "A barrier simulated example"
author: "Elias T Krainski"
date: "2023, March"
output: rmarkdown::html_vignette
bibliography: INLAspacetime.bib
vignette: >
  %\VignetteIndexEntry{INLAspacetime}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png",
  dev.args = list(type = "cairo-png"),
  fig.width = 7,
  fig.height = 5
)
knitr::opts_chunk$set(echo = TRUE)
```

# Abstract

In this tutorial we illustrate a case when there is one (potentially more) barrier
in the spatial domain and one needs to account for this when defining the model.
This illustrates the model proposed in @bakka2019barrier
as a re-implementation of the barrier model illustrated
[here](https://haakonbakkagit.github.io/index.html).

# Introduction

When there is a barrier in the spatial domain, 
the correlation between locations in each side of the barrier is affected. 
One should consider models where the correlation between points 
in two different sides of the barrier should decay to zero 
and "does not cross the domain". 

In order to illustrate the problem, 
let us define a rectangle as our spatial domain: 
```{r domain}
rxy <- c(10, 7) 
bb <- rbind(
    c(0, 1)*rxy[1],
    c(0, 1)*rxy[2])
p.domain <- cbind(
    c(0, 1, 1, 0, 0) * rxy[1],
    c(0, 0, 1, 1, 0) * rxy[2])
``` 

We will set a barrier defined as another rectangle as follows
```{r bdomain}
b.domain <- cbind(
    c(0.40, 1.50, 1.50, 0.40, 0.40) * rxy[1],
    c(0.45, 0.45, 0.55, 0.55, 0.45) * rxy[2])
b.domain <- cbind(
  c(0.45, 0.55, 0.55, 0.45, 0.45) * rxy[1], 
  c(-1, -1, 2, 2, -1) * rxy[2]
)
```

We can visualize these two rectangles in order to make the problem clear:
```{r domainvis}
par(mar = c(2, 2, 0, 0), mgp = c(2, 0.5, 0), las=1)
plot(t(bb), bty="n", type = "n")
polygon(p.domain, col = rgb(0.5,0.7,1))
polygon(b.domain, col = rgb(0.3,0.2,0.1))
```

The problem is to model data in both sides of the barrier considering that the 
correlation between then should account for the barrier. 
The proposed method in @bakka2019barrier is based in the 
Stochastic Partial Differential Approach - SPDE, see @lindgren2011explicit.
It actually models the entire domain, including the barrier, 
by setting the correlation range to be much shorter over the barrier domain 
than the one at the domain of interest. 

In the implementation illustrated this a tutorial from this 
[link](https://haakonbakkagit.github.io/index.html) 
the solution is defined by setting a fraction of the range 
to be used to set the range in the barrier. 
One should be aware on how this choice interplay with the width of the 
barrier in order to choose a small enough fraction but also not too 
small in order to prevent numerical problems. 

We first load the packages that will be used in this tutorial.

```{r packages}
library(INLA)
library(INLAspacetime)
library(inlabru)
library(ggplot2)
```

```{r lic, echo = FALSE}
inla.setOption(
    pardiso.license = "~/.pardiso.lic" 
)
```

# Mesh and triangles

The solution consider a discretization of the spatial domain and 
the simplest one is using triangles. 
Therefore we start with the following mesh made up of small triangles 
in the domain and bigger around it.
```{r mesh}
mesh <- inla.mesh.2d(
    loc.domain = p.domain, 
    max.edge = c(0.2, 0.7),
    offset = c(0.3, 2),
    cutoff = 0.1)
mesh$n
```

The solution needs the triangles inside the barrier domain to be identified. 
We start computing the center of each mesh triangle with
```{r triCenters}
triCenters <- 
    cbind(
        mesh$loc[mesh$graph$tv[,1], 1] +
        mesh$loc[mesh$graph$tv[,2], 1] +
        mesh$loc[mesh$graph$tv[,3], 1],
        mesh$loc[mesh$graph$tv[,1], 2] +
        mesh$loc[mesh$graph$tv[,2], 2] +
        mesh$loc[mesh$graph$tv[,3], 2])/3
``` 

For each triangle center we check if it is inside or not of the barrier domain 
and and create a vector to identify to which domain is each triangle center inside
```{r ibarrier}
isInBarrier <- splancs::inout(triCenters, b.domain)
``` 

We can visualize the mesh and colour the triangle centers 
using the **ggplot** methods from the **inlabru** package
```{r vmesh}
ggplot() +
    gg(mesh) +
    geom_point(aes(
        x = triCenters[,1],
        y = triCenters[,2],
        color = isInBarrier, 
        pointsize = 0.05)) + 
  theme_minimal() + xlab("") + ylab("")
```

# Data simulation 

In order to simulate some data, 
we have to define a model first. 
Let us consider that there is an underlying 
random field over the specified domain 
and one have observed some data at some locations there.

We first sample from the random field distribution. 
There are several algorithms to sample from a random field 
specified over a continuous domain without barriers. 
We will define the barrier model as 
proposed in @bakka2019barrier 
and use it to simulate. 

We will based on the mesh we have defined. 
First we have to define which of the triangles 
have centers inside the barrier. 
For that we define an integer vector:
```{r triBarrier}
triBarrier <- which(isInBarrier) 
length(triBarrier)
```

Then we compute the Finite Element Matrices needed to 
discretise the SPDE as in @bakka2019barrier 
```{r bfem}
bfem <- mesh2fem.barrier(mesh, triBarrier)
```

In order to build the precision matrix, we have to define the range over the domain. 
We also define the rage in the barrier so that the method works.  
We consider the range for the barrier as a fraction of the range over the domain. 
We just use half of the average rectangle edges as the range in the domain 
and 10% of it in the barrier. 
```{r rangesQ}
(ranges <- mean(rxy) * c(0.5, 0.05)) 
Q <- inla.barrier.q(bfem, ranges)
```

We can now simulate the field at the mesh nodes with 
```{r sample}
u <- inla.qsample(1, Q, seed = 1)[,1]
```

We can visualize the sample by projecting it into small pixesl with 
```{r gproj}
pgrid <- inla.mesh.projector(
    mesh,
    xlim = bb[1, ],
    ylim = bb[2, ],
    dims = round(300 * rxy/rxy[1]))

par(mar = c(2, 2, 0, 0), mgp = c(1.5, 0.5, 0), las = 1)
image(pgrid$x,
      pgrid$y,
      inla.mesh.project(pgrid, field = u), 
      xlab = "", ylab = "")
lines(b.domain, lwd = 2)
```

Notice that we also visualize a simulated process in the barrier because it 
is also defined there. 
We can look at this image to check if the simulated process follows the 
desired property.
That is, we can see that, because the range in the barrier is small enough, 
the correlation between points in the two sides of the barrier are independent.

We define a initial set of locations 
to consider that we observe the field at these locations. 
We start with a set of locations chosen completly at random in the rectangle 
domain, including a barrier part
```{r locs0}
xy0 <- cbind(
  runif(350, bb[1, 1], bb[1, 2]),
  runif(350, bb[2, 1], bb[2, 2])
)
``` 

Then we check which of these is inside the barrier 
```{r ib}
xy.b <- splancs::inout(xy0, b.domain)
ii <- which(!xy.b)
``` 

The locations to form the data consider only the locations in the desired domain 
and outside the barrier
```{r locs}
dataset <- data.frame(
  x = xy0[ii, 1], y = xy0[ii, 2]
)
(n <- nrow(dataset))
```

To simulate the outcome, we project the field to these locations, 
add an intercept and some random noise 
```{r dataset}
dataset$outcome <- 
    drop(inla.mesh.project(
        mesh,
        loc = cbind(dataset$x, dataset$y),
        field = u)) + 
  10 + rnorm(n, 0.0, 0.3)
```

# Model fitting 

Here we illustrate the use of the function in **INLAspacetime** to 
implement the barrier model as in @bakka2019barrier. 
Our implementation consider the `cgeneric` computational method that 
is useful to implement new models with **INLA**. 
This method allows the computations in **INLA** to take full advantage of 
parallel computations, making it faster than the original implementation.

We define the model object with
```{r bmodel}
bmodel <- barrierModel.define(
    mesh, triBarrier,
    useINLAprecomp = FALSE, 
    control.priors = list(
        prs = c(1, 0.01),
        psigma = c(1, 0.01)),
        fraction = 0.1)
``` 

Then we define the model formula, in the **inlabru** way, 
where the `field` will be the name for the spatial effect:
```{r mformulae}
model <- outcome ~ Intercept(1) +
    field(cbind(x, y), model = bmodel)
```

The **inlabru** main function will use these to run `inla` with 
```{r fit}
result <- bru(
    model, dataset, family = "gaussian")
```

# Results 

We can see the summary for the posterior marginal distribution for the intercept with 
```{r sfix}
result$summary.fix
``` 
and for the hyperparameters in the internal scale with 
```{r shyp}
result$summary.hyper
```

However, we can transform the hyperparameters from the internal 
marginal scales, from $\log(1/\sigma_e^2)$ to $\sigma$, 
from log of range to range and from log($\sigma$) to $\sigma$, 
with 
```{r pmargs}
pmarginals <- 
    list(
        data.frame(
            param = "sigma.e",
            inla.tmarginal(
                function(x) exp(-x/2),
                result$internal.marginals.hyperpar[[1]])),
        data.frame(
            param = "range",
            inla.tmarginal(
                function(x) exp(x),
                result$internal.marginals.hyperpar[[2]])),
        data.frame(
            param = "sigma",
            inla.tmarginal(
                function(x) exp(x),
                result$internal.marginals.hyperpar[[3]]))
    )
```
and extract a summary to compare with the values used to sample 
```{r psummar}
rbind(true = c(sigma.e = 0.3, range = ranges[1], sigma = 1),
      sapply(pmarginals, function(m)
             unlist(inla.zmarginal(m[, -1], TRUE))[1:2]))
```
and plot these posterior marginal distributions with 
```{r pmargsvis}
ggplot(do.call(rbind, pmarginals)) + 
    geom_line(aes(x=x, y=y)) + 
    facet_wrap(~param, scales = "free") +
    theme_minimal()
```

### The fitted field

The posterior mean of the field can be visualized with 
```{r umean}
u.mean <- inla.mesh.project(
    pgrid,
    result$summary.random$field$mean)
par(mar = c(2, 2, 0, 0), mgp = c(1.5, 0.5, 0), las = 1)
image(pgrid$x,
      pgrid$y,
      u.mean, 
      xlab = "", ylab = "")
polygon(b.domain, col = "white")
```
