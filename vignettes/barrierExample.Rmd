---
title: "A barrier simulated example"
author: "Elias T Krainski"
date: "2023, March"
output: rmarkdown::html_vignette
bibliography: INLAspacetime.bib
vignette: >
  %\VignetteIndexEntry{INLAspacetime}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png",
  dev.args = list(type = "cairo-png"),
  fig.width = 7,
  fig.height = 5
)
knitr::opts_chunk$set(echo = TRUE)
```

# Abstract

In this tutorial we illustrate a case when there is one (potentially more) barrier
in the spatial domain and one needs to account for this when defining the model.
This illustrates the model proposed in @bakka2019barrier
as a re-implementation of the barrier model illustrated
[here](https://haakonbakkagit.github.io/index.html).

# Introduction

When there is a barrier in the spatial domain, 
the correlation between locations in each side of the barrier is affected. 
One should consider models where the correlation between points 
in two different sides of the barrier should decay to zero 
and "does not cross the domain". 

In order to illustrate the problem, 
let us define a rectangle as our spatial domain: 
```{r domain}
rxy <- c(10, 7) 
bb <- rbind(
    c(0, 1)*rxy[1],
    c(0, 1)*rxy[2])
p.domain <- cbind(
    c(0, 1, 1, 0, 0) * rxy[1],
    c(0, 0, 1, 1, 0) * rxy[2])
``` 

We will set a barrier defined as another rectangle as follows
```{r bdomain}
b.domain <- cbind(
    c(0.40, 1.50, 1.50, 0.40, 0.40) * rxy[1],
    c(0.45, 0.45, 0.55, 0.55, 0.45) * rxy[2])
b.domain <- cbind(
  c(0.45, 0.55, 0.55, 0.45, 0.45) * rxy[1], 
  c(-1, -1, 2, 2, -1) * rxy[2]
)
```

We can visualize these two rectangles in order to make the problem clear:
```{r domainvis}
par(mar = c(2, 2, 0, 0), mgp = c(2, 0.5, 0), las=1)
plot(t(bb), bty="n", type = "n")
polygon(p.domain, col = rgb(0.5,0.7,1))
polygon(b.domain, col = rgb(0.3,0.2,0.1))
```

The problem is to model data in both sides of the barrier considering that the 
correlation between then should account for the barrier. 
The proposed method in @bakka2019barrier is based in the 
Stochastic Partial Differential Approach - SPDE, see @lindgren2011explicit.
It actually models the entire domain, including the barrier, 
by setting the correlation range to be much shorter over the barrier domain 
than the one at the domain of interest. 

In the implementation illustrated this a tutorial from this 
[link](https://haakonbakkagit.github.io/index.html) 
the solution is defined by setting a fraction of the range 
to be used to set the range in the barrier. 
One should be aware on how this choice interplay with the width of the 
barrier in order to choose a small enough fraction but also not too 
small in order to prevent numerical problems. 

We first load the packages that will be used in this tutorial.

```{r packages}
library(INLA)
library(INLAspacetime)
library(inlabru)
library(ggplot2)
```

```{r lic, echo = FALSE}
inla.setOption(
    pardiso.license = "~/.pardiso.lic" 
)
```

# Mesh and triangles

The solution consider a discretization of the spatial domain and 
the simplest one is using triangles. 
Therefore we start with the following mesh made up of small triangles 
in the domain and bigger around it.
```{r mesh}
mesh <- inla.mesh.2d(
    loc.domain = p.domain, 
    max.edge = c(0.2, 0.7),
    offset = c(0.3, 2),
    cutoff = 0.1)
mesh$n
```

The solution needs the triangles inside the barrier domain to be identified. 
We start computing the center of each mesh triangle with
```{r triCenters}
triCenters <- 
    cbind(
        mesh$loc[mesh$graph$tv[,1], 1] +
        mesh$loc[mesh$graph$tv[,2], 1] +
        mesh$loc[mesh$graph$tv[,3], 1],
        mesh$loc[mesh$graph$tv[,1], 2] +
        mesh$loc[mesh$graph$tv[,2], 2] +
        mesh$loc[mesh$graph$tv[,3], 2])/3
``` 

For each triangle center we check if it is inside or not of the barrier domain 
and and create a vector to identify to which domain is each triangle center inside
```{r ibarrier}
isInBarrier <- splancs::inout(triCenters, b.domain)
``` 

We can visualize the mesh and colour the triangle centers 
using the **ggplot** methods from the **inlabru** package
```{r vmesh}
ggplot() +
    gg(mesh) +
    geom_point(aes(
        x = triCenters[,1],
        y = triCenters[,2],
        color = isInBarrier, 
        pointsize = 0.05)) + 
  theme_minimal() + xlab("") + ylab("")
```

# Data simulation 

In order to simulate some data, 
we have to define a model first. 
Let us consider that there is an underlying 
random field over the specified domain 
and one have observed some data at some locations there.

We first sample from the random field distribution. 
There are several algorithms to sample from a random field 
specified over a continuous domain without barriers. 
We will define the barrier model as 
proposed in @bakka2019barrier 
and use it to simulate. 

We start defining 
a integer vector to identify which of the triangles 
have centers inside the barrier. 
```{r triBarrier}
triBarrier <- which(isInBarrier) 
length(triBarrier)
```

Then we compute the Finite Element Matrices 
for discretizing the SPDE as in @bakka2019barrier 
```{r bfem}
bfem <- mesh2fem.barrier(mesh, triBarrier)
```

Then we have to define the range over the domain and in the barrier. 
We consider the range for the barrier as a fraction of the range over the domain. 
```{r rangesQ}
(ranges <- mean(rxy) * c(0.5, 0.05)) 
```

We use this to build the precision matrix
```{r q}
Q <- inla.barrier.q(bfem, ranges)
```
and to simulate the field at the mesh nodes with 
```{r sample}
u <- inla.qsample(1, Q, seed = 1)[,1]
```

We can visualize the sample by projecting it into small pixesl with 
```{r gproj}
pgrid <- inla.mesh.projector(
    mesh,
    xlim = bb[1, ],
    ylim = bb[2, ],
    dims = round(300 * rxy/rxy[1]))

par(mar = c(2, 2, 0, 0), mgp = c(1.5, 0.5, 0), las = 1)
image(pgrid$x,
      pgrid$y,
      inla.mesh.project(pgrid, field = u), 
      xlab = "", ylab = "")
lines(b.domain, lwd = 2)
```

We define a initial set of locations
```{r locs0}
xy0 <- cbind(
  runif(350, bb[1, 1], bb[1, 2]),
  runif(350, bb[2, 1], bb[2, 2])
)
``` 
Check if some of these is inside the barrier 
```{r ib}
xy.b <- splancs::inout(xy0, b.domain)
ii <- which(!xy.b)
``` 

Create a dataset with locations in the desired domain
```{r locs}
dataset <- data.frame(
  x = xy0[ii, 1], y = xy0[ii, 2]
)
(n <- nrow(dataset))
```
project the field to this locations and some noise 
```{r dataset}
dataset$outcome <- 10 +
    drop(inla.mesh.project(
        mesh,
        loc = cbind(dataset$x, dataset$y),
        field = u)) + rnorm(n, 0.0, 0.3)
```

# Model fitting 

In order to fit the model, 
we first define the model object
```{r bmodel}
bmodel <- barrierModel.define(
    mesh, triBarrier,
    useINLAprecomp = FALSE, 
    control.priors = list(
        prs = c(1, 0.01),
        psigma = c(1, 0.01)),
        fraction = 0.1)
``` 

Then we define the model formula, in the **inlabru** way as 
```{r mformulae}
model <- outcome ~ Intercept(1) +
    field(cbind(x, y), model = bmodel)
```
and fit the model with
```{r fit}
result <- bru(
    model, dataset, family = "gaussian")
```

# Results 

We can see the summary for the posterior marginal distribution for the intercept with 
```{r sfix}
result$summary.fix
``` 
and for the hyperparameters in the internal scale with 
```{r shyp}
result$summary.hyper
```

However, we can transform the hyperparameters from the internal 
marginal scales, from $\log(1/\sigma_e^2)$ to $\sigma$, 
from log of range to range and from log($\sigma$) to $\sigma$, 
with 
```{r pmargs}
pmarginals <- 
    list(
        data.frame(
            param = "sigma.e",
            inla.tmarginal(
                function(x) exp(-x/2),
                result$internal.marginals.hyperpar[[1]])),
        data.frame(
            param = "range",
            inla.tmarginal(
                function(x) exp(x),
                result$internal.marginals.hyperpar[[2]])),
        data.frame(
            param = "sigma",
            inla.tmarginal(
                function(x) exp(x),
                result$internal.marginals.hyperpar[[3]]))
    )
```
and extract a summary to compare with the values used to sample 
```{r psummar}
rbind(true = c(sigma.e = 0.3, range = ranges[1], sigma = 1),
      sapply(pmarginals, function(m)
             unlist(inla.zmarginal(m[, -1], TRUE))[1:2]))
```
and plot these posterior marginal distributions with 
```{r pmargsvis}
ggplot(do.call(rbind, pmarginals)) + 
    geom_line(aes(x=x, y=y)) + 
    facet_wrap(~param, scales = "free") +
    theme_minimal()
```

### The fitted field

The posterior mean of the field can be visualized with 
```{r umean}
u.mean <- inla.mesh.project(
    pgrid,
    result$summary.random$field$mean)
par(mar = c(2, 2, 0, 0), mgp = c(1.5, 0.5, 0), las = 1)
image(pgrid$x,
      pgrid$y,
      u.mean, 
      xlab = "", ylab = "")
polygon(b.domain, col = "white")
```
