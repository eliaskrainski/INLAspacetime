[{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/transparent_barriers.html","id":"the-transparent-barrier-model","dir":"Articles","previous_headings":"","what":"The transparent barrier model","title":"The SPDE model with transparent barriers","text":"transparent barrier model consider domain Œ©\\Omega partitioned kk sub-domains, Œ©d\\Omega_d d‚àà{1,‚Ä¶,k}d\\\\{1,\\ldots,k\\}, ‚à™d=1kŒ©d=Œ©\\cup_{d=1}^k\\Omega_d=\\Omega. SPDE model assumes common marginal variance particular Œ©d\\Omega_d, rdr_d. Bakka et al. (2019), precision matrix ùêê=1œÉ2ùêërùêÇÃÉ‚àí1ùêër ùêër=ùêÇ+18‚àëd=1krd2ùêÜd,ùêÇÃÉr=œÄ2‚àëd=1krd2ùêÇÃÉd \\mathbf{Q} = \\frac{1}{\\sigma^2}\\mathbf{R}_r\\mathbf{\\tilde{C}}^{-1}\\mathbf{R}_r \\textrm{ }   \\mathbf{R}_r = \\mathbf{C} +  \\frac{1}{8}\\sum_{d=1}^kr_d^2\\mathbf{G}_d , \\;\\;\\; \\mathbf{\\tilde{C}}_r =  \\frac{\\pi}{2}\\sum_{d=1}^kr_d^2\\mathbf{\\tilde{C}}_d  œÉ2\\sigma^2 marginal variance. Finite Element Method - FEM matrices: ùêÇ\\mathbf{C}, defined ùêÇi,j=‚ü®œài,œàj‚ü©=‚à´Œ©œài(ùê¨)œàj(ùê¨)‚àÇùê¨, \\mathbf{C}_{,j} = \\langle \\psi_i, \\psi_j \\rangle =    \\int_\\Omega \\psi_i(\\mathbf{s}) \\psi_j(\\mathbf{s}) \\partial \\mathbf{s}, computed whole domain, ùêÜd\\mathbf{G}_d ùêÇÃÉd\\mathbf{\\tilde{C}}_d defined pair matrices subdomain (ùêÜd),j=‚ü®1Œ©d‚àáœài,‚àáœàj‚ü©=‚à´Œ©d‚àáœài(ùê¨)‚àáœàj(ùê¨)‚àÇùê¨ (ùêÇÃÉd),=‚ü®1Œ©dœài,1‚ü©=‚à´Œ©dœài(ùê¨)‚àÇùê¨. (\\mathbf{G}_d)_{,j} = \\langle 1_{\\Omega_d} \\nabla \\psi_i, \\nabla \\psi_j \\rangle =    \\int_{\\Omega_d} \\nabla \\psi_i(\\mathbf{s}) \\nabla \\psi_j(\\mathbf{s}) \\partial \\mathbf{s}\\; \\textrm{ }\\;  (\\mathbf{\\tilde{C}}_d)_{,} = \\langle 1_{\\Omega_d} \\psi_i, 1 \\rangle =    \\int_{\\Omega_d} \\psi_i(\\mathbf{s}) \\partial \\mathbf{s} . case r=r1=r2=‚Ä¶=rkr = r_1 = r_2 = \\ldots = r_k ùêër=ùêÇ+r28ùêÜ\\mathbf{R}_r = \\mathbf{C}+\\frac{r^2}{8}\\mathbf{G} ùêÇÃÉr=œÄr22ùêÇÃÉ\\mathbf{\\tilde{C}}_r = \\frac{\\pi r^2}{2}\\mathbf{\\tilde{C}} giving ùêê=2œÄœÉ2(1r2ùêÇùêÇÃÉ‚àí1ùêÇ+18ùêÇùêÇÃÉ‚àí1ùêÜ+18ùêÜùêÇÃÉ‚àí1ùêÇ+r264ùêÜùêÇÃÉ‚àí1ùêÜ) \\mathbf{Q} = \\frac{2}{\\pi\\sigma^2}( \\frac{1}{r^2}\\mathbf{C}\\mathbf{\\tilde{C}}^{-1}\\mathbf{C} +  \\frac{1}{8}\\mathbf{C}\\mathbf{\\tilde{C}}^{-1}\\mathbf{G} + \\frac{1}{8}\\mathbf{G}\\mathbf{\\tilde{C}}^{-1}\\mathbf{C} + \\frac{r^2}{64}\\mathbf{G}\\mathbf{\\tilde{C}}^{-1}\\mathbf{G}  )  coincides stationary case Lindgren Rue (2015), using ùêÇÃÉ\\tilde{\\mathbf{C}} place ùêÇ\\mathbf{C}.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/transparent_barriers.html","id":"implementation","dir":"Articles","previous_headings":"","what":"Implementation","title":"The SPDE model with transparent barriers","text":"assume rd=pdrr_d = p_d r known p1,‚Ä¶,pkp_1,\\ldots,p_k constants. gives ùêÇÃÉr=œÄr22‚àëd=1kpd2ùêÇÃÉd=œÄr22ùêÇÃÉp1,‚Ä¶,pk 18‚àëd=1krd2ùêÜd=r28‚àëd=1kpd2ùêÜÃÉd=r28ùêÜÃÉp1,‚Ä¶,pk \\mathbf{\\tilde{C}}_r =  \\frac{\\pi r^2}{2}\\sum_{d=1}^kp_d^2\\mathbf{\\tilde{C}}_d = \\frac{\\pi r^2}{2} \\mathbf{\\tilde{C}}_{p_1,\\ldots,p_k} \\textrm{ } \\frac{1}{8}\\sum_{d=1}^kr_d^2\\mathbf{G}_d = \\frac{r^2}{8}\\sum_{d=1}^kp_d^2\\mathbf{\\tilde{G}}_d =  \\frac{r^2}{8}\\mathbf{\\tilde{G}}_{p_1,\\ldots,p_k}  ùêÇÃÉp1,‚Ä¶,pk\\mathbf{\\tilde{C}}_{p_1,\\ldots,p_k} ùêÜÃÉp1,‚Ä¶,pk\\mathbf{\\tilde{G}}_{p_1,\\ldots,p_k} pre-computed matrices.","code":""},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"abstract","dir":"Articles > Web","previous_headings":"","what":"Abstract","title":"A barrier model illustration","text":"tutorial illustrate new implementation model proposed Bakka et al. (2019). consider problem modeling spatial domain accounting physical barriers. original implementation illustrated tutorial. re-implementation consider new (faster) computational method available INLA package. See details end vignette update old working code use new implementation.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"introduction","dir":"Articles > Web","previous_headings":"","what":"Introduction","title":"A barrier model illustration","text":"Suppose phenomena varies spatial domain. Models usually consider correlation observations made. Considering pair observations, correlation usually specified function distance location sites observations collected. barrier spatial domain, correlation pair observations taken sites different sides barrier shall consider barrier. resume, longer just function distance. Basically, correlation points two different sides barrier decay faster (usual) zero ‚Äúcross domain‚Äù. order illustrate problem, let us define rectangle spatial domain: now set barrier two polygons defined follows Define objects using package: can visualize polygons order make problem clear:  problem model data sides barrier considering correlation account barrier. proposed method Bakka et al. (2019) models entire domain, including barrier. deal barrier, correlation range set reasonable shorter barrier domain one domain interest. idea simple add parameter usual stationary model. Furthermore, can implemented inferential method. Bakka et al. (2019), proposed method consider Stochastic Partial Differential Equations - SPDE approach proposed Lindgren, Rue, Lindstr√∂m (2011). implementation illustrated tutorial deals discretization domain. discretization considered care. fraction fixed analysis interplay width barrier. One choose small enough fraction, see details Bakka et al. (2019). first load packages used tutorial.","code":"rxy <- c(10, 6) r <- mean(rxy) bb <- rbind(     c(0, 1)*rxy[1],     c(0, 1)*rxy[2]) domain.xy <- cbind(     c(0, 1, 1, 0, 0) * rxy[1],     c(0, 0, 1, 1, 0) * rxy[2]) barrier1 <- cbind(   cos(seq(0, 2*pi, length=50)) * 0.7 + 0.50 * rxy[1],    sin(seq(0, 2*pi, length=50)) * 1.0 + 0.75 * rxy[2]) barrier2 <- cbind(   c(0.50, 1.50, 1.50, 0.50, 0.50) * rxy[1],   c(0.33, 0.33, 0.40, 0.40, 0.33) * rxy[2]) library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE domain <- st_sfc(st_polygon(list(domain.xy))) barriers <- st_sfc(st_multipolygon(   list(st_polygon(list(barrier1)),         st_polygon(list(barrier2))))) library(ggplot2) gg0 <- ggplot() +    xlab(\"\") + ylab(\"\") +   theme_minimal() + coord_fixed() gg0 + xlim(bb[1, ]) +   geom_sf(data = domain, fill = \"blue\") +   geom_sf(data = barriers, fill = \"gray\") #> Coordinate system already present. #> ‚Ñπ Adding new coordinate system, which will replace the existing one. library(INLA) #> Loading required package: Matrix #> This is INLA_25.11.22 built 2025-11-22 08:57:21 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - List available models/likelihoods/etc with inla.list.models() #>  - Use inla.doc(<NAME>) to access documentation library(INLAspacetime) #> Loading required package: fmesher #> Loading required package: INLAtools #> Loading required package: inlabru #> see more at https://eliaskrainski.github.io/INLAspacetime library(inlabru) library(patchwork) library(fmesher)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"model-definition-and-discretization","dir":"Articles > Web","previous_headings":"","what":"Model definition and discretization","title":"A barrier model illustration","text":"Let us consider underlying random field specified domain. random field discretized using mesh precision matrix defined distribution mesh nodes. define barrier model proposed Bakka et al. (2019) make use triangulation.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"mesh-and-triangles","dir":"Articles > Web","previous_headings":"","what":"Mesh and triangles","title":"A barrier model illustration","text":"solution consider discretization spatial domain simplest one using triangles. Therefore start following mesh made small triangles domain bigger around . solution needs triangles inside barrier domain identified. triangle center check inside barrier domain create vector identify domain triangle center inside can visualize mesh color triangle centers using ggplot methods inlabru package  Notice mesh goes beyond domain area including boundary extension. also defined barrier also defined boundary. Therefore, building model discretization, barrier well defined behavior process intended.","code":"mesh <- fm_mesh_2d(     loc.domain = domain.xy,      max.edge = c(0.03, 0.1) * r,     offset = c(0.1, 0.3) * r,     cutoff = 0.01 * r) mesh$n #> [1] 4364 triBarrier <- unlist(fm_contains(   x = barriers,    y = mesh,    type = \"centroid\")) triCenters.xy <- cbind(   mesh$loc[mesh$graph$tv[,1], 1:2] +   mesh$loc[mesh$graph$tv[,2], 1:2] +   mesh$loc[mesh$graph$tv[,3], 1:2])/3 gg0 +      gg(mesh) +     geom_point(aes(         x = triCenters.xy[triBarrier, 1],         y = triCenters.xy[triBarrier, 2]))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"precision-matrix","dir":"Articles > Web","previous_headings":"Mesh and triangles","what":"Precision matrix","title":"A barrier model illustration","text":"parameters model range marginal variance, also define range parameter barrier method works. consider range barrier fraction range domain. just use half average rectangle edges range domain 10% barrier. now compute Finite Element matrices needed model discretization, detailed Bakka et al. (2019). now build precision matrix ","code":"sigma <- 1 (ranges <- r * c(0.5, 0.05))  #> [1] 4.0 0.4 bfem <- mesh2fem.barrier(mesh, triBarrier) Q <- inla.barrier.q(bfem, ranges = ranges, sigma = sigma)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"correlation","dir":"Articles > Web","previous_headings":"Mesh and triangles","what":"Correlation","title":"A barrier model illustration","text":"can use discretized model compute correlation pairs points order check properties model. Let us define function computes correlation given set location mesh node location. Consider set locations compute correlations correlation mesh node specified locations. like visualize image correlation location ‚Äúeverywhere‚Äù. Let us build projector project vector mesh nodes fine grid projected can now create data.frame expanded coordinates pixels correlations can projected prepared plotting order help visualization correlations, dropped pixels small correlations, less 0.10.1. can now visualize images  Notice model also defined barrier domain. Therefore can computations barrier. visualized correlation barriers well, added barrier borders, can see action short spatial range barriers. visual inspection helps verify short range barrier domain set small enough.","code":"localCorrel <- function(locs, mesh, Q) {   nl <- nrow(locs)   ii <- sapply(1:nl, function(i)     which.min(rowSums(sweep(       mesh$loc[, 1:ncol(locs)], 2, locs[i, ], \"-\")^2)))   b <- matrix(0, nrow(Q), nl)   for(i in 1:nl)     b[ii[i], i] <- 1   cc <- inla.qsolve(Q, b)   s <- sqrt(diag(inla.qinv(Q)))   for(i in 1:nl)     cc[, i] <- cc[, i] / (s * s[ii[i]])   return(drop(cc)) } locs <- cbind(c(0.4, 0.6, 0.7, 0.5) * rxy[1],                c(0.7, 0.6, 0.3, 0.5) * rxy[2]) mcorrels <- localCorrel(locs, mesh, Q) dim(mcorrels)  #> [1] 4364    4 pgrid <- fm_evaluator(   mesh,   lattice = fm_evaluator_lattice(     mesh,     xlim = bb[1, ],     ylim = bb[2, ],     dims = round(500 * rxy/r)   ) ) gcorrels <- as.matrix(fm_evaluate(   pgrid, field = mcorrels )) grid.df <- data.frame(   x = rep(pgrid$x, times = length(pgrid$y)),    y = rep(pgrid$y, each = length(pgrid$x))) ggcorrels <- do.call(   rbind,    lapply(1:4, function(l)      data.frame(grid.df,                 loc = paste(sprintf(\"%1.1f\", locs[l, 1]),                             sprintf(\"%1.1f\", locs[l, 2]), sep = \", \"),                 correlation = gcorrels[, l]))) gg0 +    geom_raster(     data = ggcorrels[ggcorrels$correlation>0.1, ],      mapping = aes(x = x, y = y, fill = correlation)) +    facet_wrap(~ loc) +    add.b0 + gg.add ## look to the appendix for the code for this"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"data-simulation","dir":"Articles > Web","previous_headings":"","what":"Data simulation","title":"A barrier model illustration","text":"consider random field observed noise. first sample random field distribution.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"a-random-field-sample","dir":"Articles > Web","previous_headings":"Data simulation","what":"A random field sample","title":"A barrier model illustration","text":"several algorithms sample random field specified continuous domain without barriers. use already defined precision matrix draw sample mesh nodes values sampled mesh nodes can projected set small pixels visualization purpose can now visualize projected simulated values small pixels, inclusive values barriers.  visualization simulated process barrier allows visual inspection model property. process different sides barriers seen independent, illustrated correlation plots.","code":"u <- inla.qsample(1, Q, seed = 1)[,1] #> Warning in inla.qsample(1, Q, seed = 1): Since 'seed!=0', parallel model is #> disabled and serial model is selected ugrid.sim <- fm_evaluate(pgrid, field = u) grid.df$u <- as.vector(ugrid.sim) gg0 +    geom_raster(     data = grid.df,      aes(x = x, y = y, fill = u)) +    add.b0 + gg.add ## look to the appendix for the code for this"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"sampling-a-set-of-observations","dir":"Articles > Web","previous_headings":"Data simulation","what":"Sampling a set of observations","title":"A barrier model illustration","text":"define initial set locations consider observe field locations. start set locations chosen completely random rectangle domain, including barrier part check inside barrier locations form data consider locations desired domain outside barrier simulate outcome, project field locations, add intercept random noise","code":"n0 <- 500 set.seed(2) xy0 <- cbind(   runif(n0, bb[1, 1], bb[1, 2]),   runif(n0, bb[2, 1], bb[2, 2])) ii <- which(sapply(st_intersects(   x = st_as_sf(data.frame(x=xy0[, 1], y = xy0[, 2]), coords = c('x', 'y')),   y = barriers), length)==0) dataset <- data.frame(   x = xy0[ii, 1], y = xy0[ii, 2]) (n <- nrow(dataset)) #> [1] 464 sigma.e <- 1 set.seed(3) dataset$outcome <-      drop(fm_evaluate(         mesh,         loc = cbind(dataset$x, dataset$y),         field = u)) +    10 + rnorm(n, 0.0, sigma.e)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"model-fitting","dir":"Articles > Web","previous_headings":"","what":"Model fitting","title":"A barrier model illustration","text":"illustrate use function INLAspacetime implement barrier model Bakka et al. (2019). implementation consider cgeneric computational method useful implement new models INLA. method allows computations INLA take full advantage parallel computations, achieving shorter computation time original implementation. define model object use model formula inlabru way, field name spatial effect: inlabru main function can supplied model formula, data family, follows","code":"bmodel <- barrierModel.define(     mesh = mesh,      barrier.triangles = triBarrier,     prior.range = c(1, 0.01), ## P(range < 1) = 0.01     prior.sigma = c(1, 0.01), ## P(sigma > 1) = 0.01     range.fraction = 0.1) model <- outcome ~ Intercept(1) +     field(cbind(x, y), model = bmodel) result <- bru(     model, dataset, family = \"gaussian\")"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"results","dir":"Articles > Web","previous_headings":"","what":"Results","title":"A barrier model illustration","text":"can see summary posterior marginal distribution intercept hyper-parameters computations performed internal scale. log range log(œÉ\\sigma), log(1/œÉe2)\\log(1/\\sigma_e^2). However, can transform hyper-parameters internal marginal scale scale transformed posterior marginal distributions can extract summary compare values used sample data: can also visualize posterior marginal distributions ","code":"result$summary.fix #>               mean        sd 0.025quant 0.5quant 0.975quant     mode #> Intercept 10.11302 0.4110092   9.304565  10.1042   10.97157 10.10515 #>                    kld #> Intercept 1.079871e-06 pmarginals <-      list(         data.frame(             param = \"sigma.e\",             inla.tmarginal(                 function(x) exp(-x/2),                 result$internal.marginals.hyperpar[[1]])),         data.frame(             param = \"range\",             inla.tmarginal(                 function(x) exp(x),                 result$internal.marginals.hyperpar[[2]])),         data.frame(             param = \"sigma\",             inla.tmarginal(                 function(x) exp(x),                 result$internal.marginals.hyperpar[[3]]))     ) rbind(true = c(sigma.e = sigma.e, range = ranges[1], sigma = 1),       sapply(pmarginals, function(m)              unlist(inla.zmarginal(m[, -1], TRUE))[1:2])) #>         sigma.e    range     sigma #> true 1.00000000 4.000000 1.0000000 #> mean 1.04431454 4.049196 0.9014254 #> sd   0.03812892 1.098464 0.1405383 ggplot(do.call(rbind, pmarginals)) +      geom_line(aes(x=x, y=y)) +      facet_wrap(~param, scales = \"free\") +     theme_minimal()"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"the-fitted-field","dir":"Articles > Web","previous_headings":"Results","what":"The fitted field","title":"A barrier model illustration","text":"can visualize summaries fitted field. posterior mean standard deviation can projected small pixels added raster data help visualization, filter grid pixels considering barriers. can now visualize posterior mean  estimated field, considering posterior mean shown, exhibits different pattern side barrier, particularly far tip. Therefore successfully accounted barrier model. See tutorial details visualize implied correlation two points. Similarly, can plot posterior standard deviation field, data locations used estimate model. lower values around densely sampled locations higher values otherwise. highest near boundaries, including boundary barriers, far observed locations.","code":"grid.df$u.mean <- as.vector(   fm_evaluate(     pgrid,     result$summary.random$field$mean)) grid.df$u.sd <- as.vector(   fm_evaluate(     pgrid,     result$summary.random$field$sd)) gInBarrier <- which(sapply(st_intersects(   x = st_as_sf(grid.df, coords = c('x', 'y')),   y = barriers), length)==0) gg0 +    geom_raster(     data = grid.df[!gInBarrier, ],      aes(x = x, y = y, fill = u.mean)) +    gg.add ## look to the appendix for the code for this gg0 +    geom_raster(     data = grid.df[!gInBarrier, ],      aes(x = x, y = y, fill = u.sd)) +    geom_point(data = dataset, aes(x = x, y = y)) +   gg.add ## look to the appendix for the code for this"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"appendix-a-adapting-old-code","dir":"Articles > Web","previous_headings":"","what":"Appendix A: adapting old code","title":"A barrier model illustration","text":"adapt code based tutorial, one consider two new functions implemented, detailed bellow: arguments new functions names old ones. new function used define model additional arguments. See help function details.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html","id":"appendix-b-ggplot-reused-code","dir":"Articles > Web","previous_headings":"","what":"Appendix B: ggplot reused code","title":"A barrier model illustration","text":"additional ggplot2 code used","code":"gg.add <- list(   scale_fill_distiller(     type = \"div\",      palette = \"RdBu\",      na.value = \"transparent\") ) add.b0 <- list(   geom_polygon(     mapping = aes(x, y),      data = data.frame(       x = pmin(barrier1[,1], bb[1, 2]),        y = pmin(barrier1[,2], bb[2, 2])     ), colour = \"black\",    fill = gray(0.9, 0.5)), ##\"transparent\"),   geom_polygon(     mapping = aes(x, y),      data = data.frame(       x = pmin(barrier2[,1], bb[1, 2]),        y = pmin(barrier2[,2], bb[2, 2])      ), colour = \"black\",      fill = gray(0.9, 0.5))##\"transparent\") )"},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"introduction","dir":"Articles > Web","previous_headings":"","what":"Introduction","title":"Global oceanic barrier model on the sphere","text":"tutorial, illustrate implementation barrier model proposed Bakka et al.¬†(2019) sphere. considers problem modeling spatial domain, taking account physical barriers spherical shape Earth. Since working global oceans, continents can considered physical barriers, aspect taken account modeling. using barrier model, range determined distance points. barrier two points, range decrease quickly, correlation barrier approach zero. Additionally, Earth‚Äôs spherical shape crucial factor particular case, considering planar approximation can bias results working global scale. Therefore, tutorial developed using projection onto sphere. using new implementation INLA package.","code":"## Load required libraries library(rnaturalearth) library(sf) library(ggplot2) library(INLA) library(INLAspacetime) library(inlabru) library(ggOceanMaps) library(s2) library(DOYPAColors) library(ggpubr)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"define-barriers","dir":"Articles > Web","previous_headings":"","what":"Define barriers","title":"Global oceanic barrier model on the sphere","text":"initial step define barriers model. aim model oceanic variable, essential treat continents barriers. accomplish , must establish specific parameters, including mesh resolution, maximum edge length mesh, define distance buffer simplify certain country polygons. increase mesh resolution, computational time also increase. Subsequently, use ne_countries function rnaturalearth package download data countries, employing Mollweide projection. specify want object class Simple Features (sf) ease conducting spatial operations. now create function define bounding box around earth latlong projection. used later. also need prepare grid projecting effects model, considering Mollweide projection spherical shape Earth. accomplish , implemented function called grid_create. function creates grid points within specified boundary intersect given barrier. barrier can either Simple Features (sf) Simple Features Collection (sfc) object representing geographic region, boundary can specified either providing boundary object numeric limits x y axes. point, modify barrier polygons enhance realism facilitate computation. First, calculate area polygon downloaded earlier isolated . identify small isolated islands may relevant model, exclude barrier. Moreover, give option expanding straits, Suez Canal Strait Gibraltar minimize correlation near borders. identifying area isolation polygons, remove polygons barrier considered isolated small. Likewise, plan incorporate buffers around specific regions world. example, want account closure Panama Canal, consider ice cover Antarctica, include buffer around Gulf Ob facilitate simulation. specific polygons modified, can proceed integrate multipolygon world countries. also use st_simplify function simplify borders polygons preserving topology domain.","code":"## Mesh resolution (bigger number increases the resolution) sresol <- 30   ## This resolution will gives the approximate maximum edge length (in km)  max_edge <- 36080.2 * 0.2 / sresol units(max_edge) <- \"km\"  ## Set a minimum distance to be used for simplification of polygons dist_simplify <- 20 units(dist_simplify) <- \"km\"  ## Set a buffer distance to be added to certain polygons  bufferdist <- max_edge / 2 ## Download country boundaries data at a medium scale world_ll <- ne_countries(scale = \"medium\", returnclass = \"sf\")  ## Retrieve the coordinate reference system (CRS) of the downloaded data crs_ll <- st_crs(world_ll)  ## Define Mollweide projection  crs_vis <- st_crs(\"+proj=moll +units=km +units=km\")  ## Transform the country boundaries data to the Mollweide projection world_mll <- st_transform(st_geometry(world_ll), crs_vis) ## function to create a Earth polygon Earth_poly <- function(resol = 100) {     st_sfc(st_multipolygon(         list(st_polygon(list(cbind(             long = c(                 seq(-1, 1, length.out = resol * 2 + 1), rep(1, resol + 1),                 seq(1, -1, length.out = resol * 2 + 1), rep(-1, resol + 1)             ) * (180 - 1e-5),             lat = c(                 rep(1, resol * 2 + 1), seq(1, -1, length.out = resol + 1),                 rep(-1, resol * 2 + 1), seq(-1, 1, length.out = resol + 1)             ) * (90 - 1e-5)         ))))), crs = \"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\") } ## Function to create the grid for projection while considering the barrier grid_create <- function(barrier, resol = 50) {   if (!inherits(barrier, c(\"sf\", \"sfc\"))) {     stop(\"barrier must be sf or sfc objects.\")   }   Ell <- Earth_poly(resol = 100)   if (st_crs(Ell) != st_crs(barrier)) {     Ell_transformed <- st_transform(Ell, st_crs(barrier))   } else {     Ell_transformed <- Ell   }   grid_0 <- st_as_sf(     expand.grid(x = seq(from = min(st_coordinates(Ell_transformed)[,1]),                          to = max(st_coordinates(Ell_transformed)[,1]),                          by = resol),                 y = seq(from = min(st_coordinates(Ell_transformed)[,2]),                          to = max(st_coordinates(Ell_transformed)[,2]),                          by = resol)),     coords = 1:2, crs = st_crs(barrier))   ig_0 <- which(sapply(st_intersects(grid_0, Ell_transformed), length) > 0)   ig_sel <- setdiff(ig_0,                    which(sapply(st_intersects(grid_0, barrier), length) > 0)   )   grid_mll <- grid_0[ig_sel, ]   return(grid_mll) }  ## Grid in Mollweide  mgrid <- grid_create(barrier = world_mll)  ## Grid in latlong  grid_ll <- st_transform(mgrid, crs = crs_ll)  ## Transform to the sphere  mgrid_sph <- fm_transform(     mgrid,     crs = fm_crs(\"sphere\") ) ## Compute the area of each polygon world_area <- st_area(world_mll)  ## Extract the neighbor list from this map (consider neighbor if any coordinate within the buffer distance) nb <- spdep:::poly2nb(                 pl = world_mll,                 snap = as.numeric(bufferdist))  ## Number of neighbors nn <- spdep::card(nb)  ## Identify small multipolygons (area smaller than square of the approximated maximum length of the edges in the modeling domain) wpolyclass <- paste(ifelse(sqrt(world_area) > max_edge, \"big\", \"small\"),                     ifelse(nn>0, \"connected\", \"isolated\")) ## Enlarge Suez canal ## Define the coordinates for the Suez canal polygon suez_ll <- matrix(     c(31.6, 31.7, 43.9, 43.8, 31.6,       31.5, 31.7, 12.0, 11.8, 31.5),     ncol = 2, byrow = FALSE)  ## Create a Simple Features (sf) polygon for the Suez canal suez_ll <- sf::st_sfc(     sf::st_polygon(         list(suez_ll)     ), crs = crs_ll )  ## Transform the Suez canal polygon and create a buffer suez_mll <- st_buffer(     st_transform(suez_ll, crs_vis),     dist = bufferdist )  ## Enlarge strait of Gibraltar  ## Define the coordinates for the Strait of Gibraltar polygon gibra_ll <- matrix(     c(-6.0, -5.2, -5.2, -6.0, -6.0,       36.0, 36.0, 35.9, 35.9, 36.0),      ncol = 2, byrow = FALSE)  ## Create a Simple Features (sf) polygon for the Strait of Gibraltar gibra_ll <- sf::st_sfc(     sf::st_polygon(         list(gibra_ll)     ), crs = crs_ll )  ## Transform the Strait of Gibraltar polygon and create a buffer gibra_mll <- st_buffer(     st_transform(gibra_ll, crs_vis),     dist = bufferdist )  ## Enlarge Turkish straits  ## Define the coordinates for the Turkish straits polygon turk_ll <- matrix(   c(26.1, 39.95,     29.35, 41.15,     29.3, 41.35,     26.05, 40.15,     26.1, 39.95),     ncol = 2, byrow = TRUE )  ## Create a Simple Features (sf) polygon for the  Turkish straits turk_ll <- sf::st_sfc(     sf::st_polygon(         list(turk_ll)     ), crs = crs_ll )  ## Transform the Turkish straits polygon and create a buffer turk_mll <- st_buffer(     st_transform(turk_ll, crs_vis),     dist = bufferdist/6 ) ### Remove small and isolated polygons world_barrier_initial <- st_difference(     world_mll[wpolyclass != \"small isolated\"],     st_union(c(suez_mll, gibra_mll, turk_mll))     ) ## Panama country polygon retrieval and buffer creation panm_ll <- ne_countries(country = \"panama\", scale = \"medium\", returnclass = \"sf\") panm_mll <- st_buffer(     st_transform(st_geometry(panm_ll), crs_vis),     dist = bufferdist)  ## Define the coordinates for the Gulf of Ob polygon gulf_ll <- matrix(   c(70, 78, 78, 70, 70,     65, 65, 73, 73, 65),    ncol = 2, byrow = FALSE)  ## Create a Simple Features (sf) polygon for the Gulf of Ob gulf_ll <- sf::st_sfc(   sf::st_polygon(     list(gulf_ll)   ), crs = crs_ll )  ## Transform the Gulf of Ob polygon and create a buffer  gulf_mll <- st_buffer(   st_transform(gulf_ll, crs_vis),   dist = bufferdist)  ## Download Antarctica polygon antar_ll <- ne_countries(country = \"Antarctica\", scale = \"medium\", returnclass = \"sf\")  ## Include a buffer  antar_mll <- st_buffer(   st_transform(st_geometry(antar_ll), crs_vis),   dist = bufferdist) ## Buffer world land world_lnd <- st_union(c(world_barrier_initial, panm_mll, gulf_mll, antar_mll))  ## World land excluding the Suez canal, Turkish straits, and Gibraltar strait  world_dff <- st_difference(     x = world_lnd,     y = st_union(c(suez_mll, gibra_mll, turk_mll)) )  ## World land without modifications for visualization world_union <- st_union(world_mll)  ## Join and simplify the boundary of the barrier domain so that very detailed parts would be smoothed out world_barrier <- st_simplify(     world_dff,      preserveTopology = FALSE,     dTolerance = dist_simplify)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"classifying-polygon-areas","dir":"Articles > Web","previous_headings":"Define barriers","what":"Classifying polygon areas","title":"Global oceanic barrier model on the sphere","text":"Classify polygons based size, TRUE indicates large polygon, FALSE indicates small polygon.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"classifying-polygon-loneliness","dir":"Articles > Web","previous_headings":"Define barriers","what":"Classifying polygon loneliness","title":"Global oceanic barrier model on the sphere","text":"Classify polygons based size connectivity, polygon can categorized either big small connected isolated.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"buffers-and-straits","dir":"Articles > Web","previous_headings":"Define barriers","what":"Buffers and straits","title":"Global oceanic barrier model on the sphere","text":"Modifications implemented globe generate barrier model.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"barrier-polygons","dir":"Articles > Web","previous_headings":"Define barriers","what":"Barrier polygons","title":"Global oceanic barrier model on the sphere","text":"Barrier polygons filtering small isolated polygons specifying modifications open close certain areas.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"mesh-creation","dir":"Articles > Web","previous_headings":"","what":"Mesh Creation","title":"Global oceanic barrier model on the sphere","text":"barrier model proposed Bakka et al.¬†(2019), involves triangulation method. Therefore, going consider underlying random field whole sphere; random field discretized using mesh, defining precision matrix distribution mesh nodes. order work efficiently, simulate higher-resolution points outside barrier using fmesher_globe_points function. allows us utilize initial points reduce number nodes inside barrier. Consequently, improve computation speed without compromising results model. ‚Äôs crucial note mesh designed consideration sphere (fm_transform), allowing us work three dimensions. definition points projection, can generate mesh examine number nodes contains. particular scenario, mesh comprises total 7068 nodes. achieve , utilize fm_rcdt_2d function, specifying globe argument desired resolution, crs sphere, loc high-resolution points previously created, cutoff avoid tiny triangles. Now, can perform operations mesh using different map projections. interested utilizing Mollweide projection plotting mesh. achieve , employ fm_transform function. Since working barrier model, need identify mesh nodes inside barriers. , use function fm_contains, finds triangle centroids vertices inside sf sp polygon objects.","code":"## Create a initial set of points over the globe considering the desired resolution reg.glob.pts <- fmesher_globe_points(     globe = sresol ## subdivision resolution for a semi-regular spherical triangulation with equidistant points along equidistant latitude bands )  ## Project it to the working projection (sphere) inipts0 <- fm_transform(     st_as_sf(as.data.frame(reg.glob.pts),              coords = 1:3,              crs = fm_crs(\"sphere\")),     fm_crs(world_barrier))  ## Verify which of these points are inside an extended model domain in_ocean <- which(sapply(st_intersects(     inipts0,     st_buffer(st_union(world_lnd), dist = - bufferdist/2) ), length)==0) ## Create a triangular mesh on the globe with a specified resolution smesh <- fm_rcdt_2d_inla(     loc = reg.glob.pts[in_ocean, ], ## use the initial points     globe = 10, ## we use lower resolution for the rest (barrier) of the domain     cutoff = 1 / sresol, ## to avoid tiny triangles     crs = fm_crs(\"sphere\") ## the 'CRS' for the mesh over the sphere )  ## Number of nodes smesh$n ## [1] 6978 ## Collect the mesh locations and directly transform it to the Mollweide projection lmesh_mll <- fm_transform(     st_as_sf(as.data.frame(smesh$loc), coords = 1:3,              crs = fm_crs(smesh)),      crs = crs_vis) ## Extract triangles containing barriers triBarrier <- unlist(fm_contains(   x = world_barrier, ## Barrier polygons   y = smesh, ## Mesh    type = \"centroid\"  ))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"initial-points","dir":"Articles > Web","previous_headings":"Mesh Creation","what":"Initial points","title":"Global oceanic barrier model on the sphere","text":"Generation initial points mesh throughout domain.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"mesh-with-barriers","dir":"Articles > Web","previous_headings":"Mesh Creation","what":"Mesh with barriers","title":"Global oceanic barrier model on the sphere","text":"Representation mesh nodes sphere: nodes inside barrier black, outside blue.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"correlation-values-at-specific-points","dir":"Articles > Web","previous_headings":"","what":"Correlation values at specific points","title":"Global oceanic barrier model on the sphere","text":"can utilize discretized model calculate correlations pairs points assess model properties simulation. Initially, essential define key parameters barrier model, aligning SPDE model: practical range marginal variance (Lindgren et al.¬†2011). barrier‚Äôs range determined fraction range across entire domain. Specifically, set range 0.63, corresponding 4000 km. proximity barrier, use 0.008 value range. , need use already defined function localCorrel2D tutorial ‚ÄúBarrier Model Illustration‚Äù (https://github.com/eliaskrainski/INLAspacetime), compute correlation given set locations mesh node location (minor changes function). start selecting various locations transform Mollweide coordinates. chosen locations close barriers barriers, ‚Äôs easy verify model working properly. observe decrease around barrier. also convert mesh latitude longitude coordinates, allowing us work 2D representation mesh. Locations computing correlations. , use function previously defined, localCorrel2D, compute correlation. Since function works 2D dimension need use mesh latitude longitude projection (mesh_locs_ll) previously define, can work correlation planar. correlation can projected visualized ‚Äúeverywhere‚Äù. However, essential transform grid coordinates onto sphere initially, considering mesh projected three dimensions. gproj spherical coordinates, can transform kilometer coordinates using Mollweide projection visualization. Correlation value 2 selected spatial points","code":"## Create a barrier model using the mesh  bfem <- mesh2fem.barrier(smesh, triBarrier)  ## Set parameters for barrier field simulation sigma <- 1 ## standard deviation  ranges <- c(4000, 50) / (s2::s2_earth_radius_meters()/1e3) ## practical range: 4000km  ## Create a precision matrix with the specified parameters Q <- inla.barrier.q(bfem, ranges = ranges, sigma = sigma) ## Define a function for calculating local correlations localCorrel2D <- function(locs, mesh.locs, Q) {     nl <- nrow(locs)  ## Number of locations      ii <- sapply(1:nl, function(i)         which.min(s2_distance(             mesh.locs, locs[i,],             radius = s2_earth_radius_meters()))         )  ## Indices of the closest locations on the mesh           b <- matrix(0, nrow(Q), nl)  ## Initialize a matrix of zeros     for (i in 1:nl)         b[ii[i], i] <- 1  ## Set 1 at positions corresponding to the closest locations          cc <- inla.qsolve(Q, b)  ## Solve the linear system Q * cc = b     s <- sqrt(diag(inla.qinv(Q)))  ## Calculate the square root of the diagonal of the inverse of Q     for (i in 1:nl)         cc[, i] <- cc[, i] / (s * s[ii[i]])  ## Normalize local correlations     return(drop(cc))  ## Return normalized local correlations } ## Locations for correlation calculation locs_ll <- matrix(c(     -60, 70,     -90, 10,      25, 34,     122,  4,     40, -20,     175, -45 ), ncol = 2, byrow = TRUE)  ## Create spatial points for visualization locs_latlong <- st_as_sf(     x = as.data.frame(locs_ll),     coords = 1:2, crs = crs_ll)  ## Mesh nodes in longlat projection mesh_locs_ll <- sf::st_as_sf( ## Convert foreign object to an sf object   data.frame(     inla.mesh.map(smesh$loc, ## Calculates coordinate for inla.mesh projection                   projection = \"longlat\", ## the projection type                   inverse = FALSE ## means that locations (loc) are coordinates in the mesh domain     )   ),   coords = c(1, 2),   crs = \"+proj=longlat +ellps=WGS84\" ) ## Calculate local correlations mcorrels <- localCorrel2D(     locs_latlong, ## locations     mesh_locs_ll, ## mesh projected     Q ## precision matrix ) ## Create a grid projector using the mesh and spherical grid gproj <- inla.mesh.projector(mesh = smesh, loc = mgrid_sph)  ## Project local correlations to the grid gcorrels <- -1 + 2 * plogis(as.matrix(inla.mesh.project(   gproj, field = qlogis(0.5 + (0.5 -1e-9) * mcorrels) )))  ## Create a data frame for correlation visualization mgrid_cor <- st_coordinates(mgrid)    ## Combine data for ggplot ggcorrels <- do.call(   rbind,    lapply(1:nrow(locs_ll), function(l)        data.frame(           mgrid_cor,            loc = paste0(               \"l\", l, \": (\",               sprintf(\"%1.1f\", locs_ll[l, 1]), \", \",               sprintf(\"%1.1f\", locs_ll[l, 2]), \")\"),            correlation = gcorrels[, l])))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"simulation-of-the-space-time-barrier-model","dir":"Articles > Web","previous_headings":"","what":"Simulation of the space-time barrier model","title":"Global oceanic barrier model on the sphere","text":"established parameters (range standard deviation) previous section verified properties, can proceed compute simulated random field barrier model. Subsequently, can project random field onto defined grid visualization. Since working space time, simulated total 6 random fields. , ensure independent , going correlate using autoregressive model order 1 (AR1).","code":"## Number of years k  k <- 6  ## Initialize lists to store random seeds and spatial fields seed <- c(345,1,123,663,2314,654) u <- list()  ## Generate random samples for each spatial field for(i in 1:k) {   u[[i]] <- inla.qsample(1, Q, seed = seed[[i]]) }  ## Project the field grid onto the Mollweide projection grid_sf <- list() for(i in 1:k) {   grid_sf[[i]] <- st_as_sf(data.frame(     st_coordinates(mgrid),     u_proj = inla.mesh.project(gproj, as.vector(u[[i]]))),     coords = 1:2, crs = crs_vis) } ## Autoregressive smoothing rho <- 0.98 u_time <- u for(i in 2:k) {   u_time[[i]] <- rho * u_time[[i-1]] + sqrt(1-rho^2) * u_time[[i]] }  ## Project the field grid onto the Mollweide projection grid_sf_u <- list() for(i in 1:k) {   grid_sf_u[[i]] <- st_as_sf(data.frame(     st_coordinates(mgrid),     u_proj = inla.mesh.project(gproj, as.vector(u_time[[i]]))),     coords = 1:2, crs = crs_vis) }"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"simulated-random-fields-independent-space-time-effect","dir":"Articles > Web","previous_headings":"Simulation of the space-time barrier model","what":"Simulated random fields (independent space-time effect)","title":"Global oceanic barrier model on the sphere","text":"Simulated spatial random fields. random field independent .","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"simulated-random-fields-dependent-space-time-effect","dir":"Articles > Web","previous_headings":"Simulation of the space-time barrier model","what":"Simulated random fields (dependent space-time effect)","title":"Global oceanic barrier model on the sphere","text":"Simulated spatial random fields, including autoregressive model order 1.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"simulation-of-locations","dir":"Articles > Web","previous_headings":"","what":"Simulation of locations","title":"Global oceanic barrier model on the sphere","text":"Regarding simulation response variable, first need determine set locations variable observed. achieve , simulate n values polygon within limits domain, observations vary time. Note simulation locations takes account coordinate reference system (CRS). Without CRS, disproportionately large number points near poles compared equator. discrepancy arises due Earth‚Äôs shape, utilizing CRS helps maintain balanced accurate representation simulations. Point need exclude points inside barrier, response variable observed inside. Furthermore, transform points onto sphere using fm_transform function, allowing us fit model later 3D. Spatial points observed response variable","code":"## Generate random data locations in longlat ## Create world-size sampling area without crs world_poly_wgs84 <- Earth_poly(resol = 100)  ## Add WGS84 crs to a duplicated object st_crs(world_poly_wgs84) <- 4326  ## convert to the Mollweid projection world_poly_planar <- st_transform(   x = world_poly_wgs84,    crs = crs_vis )  ## Sample the locations for each time set.seed(34521) ## Number of observations n <- 5000  sf::sf_use_s2(FALSE) locs_mll <- list() ## Random sampling seed_2 <- c(34521, 323,43454,24213,2311,2344) for(i in 1:k) {   set.seed(seed_2[[i]])   locs_mll[[i]] <- sf::st_sample(world_poly_planar, n, type = \"random\",                                  oriented=TRUE,                                  exact = TRUE) }  ## Transform data locations to the longlat projection locs_ll <- list() for(i in 1:k) {   locs_ll[[i]] <- st_transform(locs_mll[[i]], crs = st_crs(world_poly_wgs84)) } ## Identify locations outside the world polygon in Mollweide projection ilocs_in <- list() locs <- list() for(i in 1:k) {   ilocs_in[[i]] <- which(sapply(st_intersects(     locs_mll[[i]], world_barrier), length) == 0)   ## extract the coordinates   locs[[i]] <- st_coordinates(locs_ll[[i]])[ilocs_in[[i]], ] } ## Map the data locations back to the sphere locs_sph <- list() for(i in 1:k) {   locs_sph[[i]] <- fm_transform(     x = locs_mll[[i]][ilocs_in[[i]]],     crs = fm_crs(\"sphere\")) }"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"covariate-depth","dir":"Articles > Web","previous_headings":"","what":"Covariate: depth","title":"Global oceanic barrier model on the sphere","text":", aim include continuous covariate linear effect. , going use ocean depth consider negative linear effect. Note download depth data, need run R outside Quarto Rmarkdown. need . missing data, going eliminate locations depth associated. Finally, removing missing data, can update previously simulated locations retain points corresponding depth value. projected filtered locations onto sphere using fm_transform function. Scale values depth selected locations","code":"depth_values <- list() for(i in 1:k) {       depth_values[[i]] <- get_depth(as.data.frame(locs[[i]])) } ## Create a new data frame 'locs_latlong' with columns 'x', 'y', and 'depth' locs_latlong <- list() for(i in 1:k) {  locs_latlong[[i]] <- data.frame(x = depth_values[[i]]$X,                            y = depth_values[[i]]$Y,                            depth = depth_values[[i]]$depth)  }  ## Use 'depth' in kilometers for easier interpretation in the 'locs_latlong' data frame for(i in 1:k) {  locs_latlong[[i]]$depth <- as.vector(locs_latlong[[i]]$depth / 1000)  }  ## Remove rows with missing values in the 'locs_latlong' data frame for(i in 1:k) {   locs_latlong[[i]] <- na.omit(locs_latlong[[i]]) }  ## Calculate the new number of rows in the modified 'locs_latlong' data frame n_new <- list() for(i in 1:k) {   n_new[[i]] <- nrow(locs_latlong[[i]]) }  ## Create a spatial features object (sf)  depth_sf <- list() depth_mll <- list() for(i in 1:k) {  depth_sf[[i]] <- st_as_sf(locs_latlong[[i]], coords = c(1, 2), crs = crs_ll)  depth_mll[[i]] <- st_transform(depth_sf[[i]], crs = crs_vis)  } ## Transform from data.frame to sf object locs_filter <- list() for(i in 1:k) {   locs_filter[[i]] <- st_as_sf(locs_latlong[[i]],                                coords = c(\"x\", \"y\"), crs = crs_ll) }  ## Map the data locations back to the sphere locs_sph <- list() for(i in 1:k) {   locs_sph[[i]] <- fm_transform(     x = locs_filter[[i]],     crs = fm_crs(\"sphere\")) }"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"response-variable-space-and-space-time","dir":"Articles > Web","previous_headings":"","what":"Response variable space and space-time","title":"Global oceanic barrier model on the sphere","text":"tutorial, fit four different scenarios: 1) spatial Normal response variable, 2) spatial Bernoulli response variable, 3) space-time Normal response variable, 4) space-time Bernoulli response variable. Therefore, two spatial scenarios another two space-time scenarios. Likewise, illustrate fit Normal Bernoulli distributions.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"space-time-response-variables","dir":"Articles > Web","previous_headings":"Response variable space and space-time","what":"Space-time response variables","title":"Global oceanic barrier model on the sphere","text":"Next, going simulate response variables, including time effect. Therefore, two different space-time datasets: one Normal response variable another one Bernoulli response variable.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"normal-distribution","dir":"Articles > Web","previous_headings":"Response variable space and space-time > Space-time response variables","what":"Normal distribution","title":"Global oceanic barrier model on the sphere","text":"normal response variable, use simulated random fields. Subsequently, prepare data.frame coordinates sphere values depth simulated response coordinates fitting model. Values response variable space time","code":"## Create sparse precision matrices for data locations Alocs_time <- list() for(i in 1:k) {   Alocs_time[[i]] <- inla.spde.make.A(     mesh = smesh, loc = locs_sph[[i]]) }  ## Set parameters for data simulation beta0_norm <- 10 ## Intercept beta1_norm <- -1.5 ## Depth coefficient sigma_e <- 0.3 ## Gaussian standard deviation  ## Simulate the response variable y set.seed(356) y_norm_t <- list() for(i in 1:k) {   y_norm_t[[i]] <- rnorm(n_new[[i]], beta0_norm +                            beta1_norm * locs_latlong[[i]]$depth +                            drop(Alocs_time[[i]] %*% u_time[[i]]), sigma_e) }  ## Create a data frame for the simulated data data_f_norm_t <- list() for(i in 1:k) {  data_f_norm_t[[i]] <- st_as_sf(   data.frame(     locs_latlong[[i]][,c(1,2)],     z = y_norm_t[[i]]),   coords = c(1, 2),   crs = crs_ll)  }  ## Visualize the simulated data on the Mollweide projection data_mll_norm_t <- list() locs_mll_data_norm_t <- list() for(i in 1:k) {  data_mll_norm_t[[i]] <- st_transform(data_f_norm_t[[i]], crs = crs_vis) locs_mll_data_norm_t[[i]] <- st_coordinates(data_mll_norm_t[[i]])  }  ## Combine data from all time steps for modeling data_model_norm_t <- data.frame() for (i in 1:k) {   coordinates <- locs_sph[[i]]   y_response <- data_mll_norm_t[[i]]$z   depth <- locs_latlong[[i]]$depth      data_model_norm_t <- rbind(data_model_norm_t, data.frame(     time = rep(i, nrow(st_coordinates(coordinates))),     y = y_response,     depth = depth,      x_coord = st_coordinates(coordinates)[,1],     y_coord = st_coordinates(coordinates)[,2],     z_coord = st_coordinates(coordinates)[,3]   )) }"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"bernouilli-distribution","dir":"Articles > Web","previous_headings":"Response variable space and space-time > Space-time response variables","what":"Bernouilli distribution","title":"Global oceanic barrier model on the sphere","text":", Bernoulli distribution, follow steps, considering probability parameter interest. Values response variable space time","code":"## Set parameters for data simulation beta0_ber <- 1 ## Intercept beta1_ber <- -1.5 ## Depth coefficient  ## Simulated probability p_time <- list() for(i in 1:k) {   p_time[[i]] <- boot::inv.logit(beta0_ber +                         beta1_ber * locs_latlong[[i]]$depth +                        drop(Alocs_time[[i]] %*% u_time[[i]])) }  ## Data.frame with the probability data_prob_t <- list() for(i in 1:k) {   data_prob_t[[i]] <- data.frame(locs_latlong[[i]],                         prob = p_time[[i]]) }  set.seed(356) y_ber_t <- list() for(i in 1:k) {   y_ber_t[[i]] <- rbinom(n = length(data_prob_t[[i]]$prob), 1, prob = data_prob_t[[i]]$prob)   data_prob_t[[i]]$response <- y_ber_t[[i]] }   ## Create a data frame for the simulated data data_f_ber_t <- list() for(i in 1:k) {   data_f_ber_t[[i]] <- st_as_sf(   data.frame(     locs_latlong[[i]][,c(1,2)],     z = data_prob_t[[i]]$response   ),   coords = c(1, 2),   crs = crs_ll) }  ## Visualize the simulated data on the Mollweide projection data_mll_ber_t <- list() locs_mll_ber_t <- list() for(i in 1:k) {  data_mll_ber_t[[i]] <- st_transform(data_f_ber_t[[i]], crs = crs_vis) locs_mll_ber_t[[i]] <- st_coordinates(data_mll_ber_t[[i]])  }  ## Combine data from all time steps for modeling data_model_ber_t <- data.frame() for (i in 1:k) {   coordinates <- locs_sph[[i]]   y_response <- data_mll_ber_t[[i]]$z   depth <- locs_latlong[[i]]$depth      data_model_ber_t <- rbind(data_model_ber_t, data.frame(     time = rep(i, nrow(st_coordinates(coordinates))),     y = y_response,     depth = depth,      x_coord = st_coordinates(coordinates)[,1],     y_coord = st_coordinates(coordinates)[,2],     z_coord = st_coordinates(coordinates)[,3]   )) }"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"fit-the-barrier-model","dir":"Articles > Web","previous_headings":"","what":"Fit the barrier model","title":"Global oceanic barrier model on the sphere","text":"begin, define model object using barrierModel.define function. step, specify details mesh, barrier, PC priors random field hyperparameters, fraction range barrier close proximity. scenarios. fit model using inla base code inlabru. approaches, necessary create data.frame containing three-dimensional location, depth values, simulated response variable values.","code":"## Define a barrier model using the mesh and specified prior parameters bmodel <- barrierModel.define(   mesh = smesh, ## mesh in 3D   barrier.triangles = triBarrier, ## Barriers (world countries)   prior.range = c(0.5, 0.1), ## P(range < 0.5) = 0.1   prior.sigma = c(1, 0.1), ## P(range > 1) = 0.1   range.fraction = 0.008 ## range at the barriers  )"},{"path":[]},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"inlabru","dir":"Articles > Web","previous_headings":"Fit the barrier model > Spatial scenarios > Normal response variable","what":"INLABRU","title":"Global oceanic barrier model on the sphere","text":"use model formula inlabru way, field name spatial effect. main function inlabru bru, just need specify model formula (model), data (dataset), family (gaussian). also turn verbose argument able see fitting process running. fitted model, can observe get back results. First, check summary fixed effect hyperparameters. Summary posterior distribution fixed effects. Summary posterior distribution hyperparameters , compute marginals hyperparameters: range rr, standard deviation spatial effect œÉ\\sigma, standard deviation Gaussian distribution œÉe\\sigma_{e}. Likewise, can plot marginals fixed effects: intercept depth linear coefficients. can also visualize predicted random field. case, compute mean spatial field also standard deviation.","code":"## Specify the model formula model_norm <- y ~   ## Intercept   Intercept(1) +   ## Depth linear effect   bat(depth, model = \"linear\") +   ## Spatial effect   field(cbind(x_coord,y_coord,z_coord),         model = bmodel #The barrier model         )  ## Fit the Bayesian model using INLA set.seed(2353) result_norm <- bru(     model_norm, data_model_norm_t[data_model_norm_t$time == 1,][,-1],     family = \"gaussian\",     options = list(         verbose = TRUE,         control.compute = list(cpo = TRUE))) ## Beta 0 (intercept) and Beta 1 (depth) res_summary_fixed_rounded <- round(result_norm$summary.fixed, 2) ## Range, standard deviation (spatial effect), and standard deviation (Gaussian) res_summary_hyper_rounded <- round(result_norm$summary.hyperpar, 2) ## Create a list of hyperparameter marginals for visualization pmarginals <-    list(     data.frame(       param = \"sigma.e\",       inla.tmarginal(         function(x) exp(-x/2),         result_norm$internal.marginals.hyperpar$`Log precision for the Gaussian observations`)),     data.frame(       param = \"range\",       inla.tmarginal(         function(x) exp(x),         result_norm$internal.marginals.hyperpar$`Theta1 for field`)),     data.frame(       param = \"sigma\",       inla.tmarginal(         function(x) exp(x),         result_norm$internal.marginals.hyperpar$`Theta2 for field`))   )  ## Add true values and quantiles to hyperparameter marginals pmarginals[[1]]$true <- rep(sigma_e, length(pmarginals[[1]]$x)) pmarginals[[2]]$true <- rep(ranges[1], length(pmarginals[[1]]$x)) pmarginals[[3]]$true <- rep(1, length(pmarginals[[1]]$x)) ## Create a list of parameter marginals for visualization fmarginals <-    list(     data.frame(       param = \"intercept\",       value = result_norm$marginals.fixed$Intercept     ),     data.frame(       param = \"depth\",       value = result_norm$marginals.fixed$bat     )   )  ## Add true values and quantiles to parameter marginals fmarginals[[1]]$true <- rep(beta0_norm, length(fmarginals[[1]]$value.x)) fmarginals[[2]]$true <- rep(beta1_norm, length(fmarginals[[2]]$value.y)) ## Add mean and standard deviation of the field to the grid  grid_sf[[1]]$u_mean <- as.vector( ## mean    inla.mesh.project(       gproj,        result_norm$summary.random$field$mean))  grid_sf[[1]]$u_sd <- exp(as.vector( ## standard deviation   inla.mesh.project(     gproj,      log(result_norm$summary.random$field$sd))))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"hyperparameters-posterior-distributions","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Marginals posterior distributions hyperparameters (red line represents true value)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"fixed-parameters","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Marginals posterior distributions fixed parameters (red line represents true value)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"simulated-vs-posterior-mean-of-the-random-field","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Simulated random field (u) compared posterior mean random field (u.mean)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"posterior-standard-deviation-of-the-field","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Posterior standard deviation random field observed points (black docs)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"inla","dir":"Articles > Web","previous_headings":"Fit the barrier model > Spatial scenarios > Normal response variable","what":"INLA","title":"Global oceanic barrier model on the sphere","text":"following code fits model using INLA base code. accomplish , INLA stack initially created model response variable according specified formula. stack includes projector matrix (Alocs), spatial effect (), depth (beta1), intercept (beta0). fitted model, can observe get back results. First, check summary fixed effect hyperparameters. Summary posterior distribution fixed effects. Summary posterior distribution hyperparameters , compute marginals hyperparameters: ranges rr, standard deviation spatial effect œÉ\\sigma, standard deviation Gaussian distribution œÉe\\sigma_{e}. Likewise, can plot marginals fixed parameters: intercept depth linear coefficient. can also visualize predicted random field. case, compute mean spatial field also standard deviation.","code":"## Create an INLA stack (stk) for modeling the response variable based on the specified formula and data stk <- inla.stack(   data = list(resp = data_model_norm_t[data_model_norm_t$time == 1,]$y), ## Response variable   A = list(Alocs_time[[1]], 1,1),  ## Projector matrix   effects = list(i = 1:bmodel$mesh$n, ## Spatial effect                  beta1 = data_model_norm_t[data_model_norm_t$time == 1,]$depth, ## Depth                   beta0 = rep(1,nrow(data_model_norm_t[data_model_norm_t$time == 1,])) ## Intercept   ),   tag = \"est\" ## Estimation stack (est) )  ## Use inla to fit the specified formula and obtain the result set.seed(52134) result_norm <- inla(resp ~ 0 + beta0 + f(beta1, model = \"linear\") + f(i, model = bmodel), ## Formula             data = inla.stack.data(stk), ## Stack             control.predictor = list(A = inla.stack.A(stk),                                      compute = TRUE),             control.compute = list(return.marginals.predictor = TRUE),             verbose = TRUE) ## Beta 0 (intercept) and Beta 1 (depth) res_summary_fixed_rounded <- round(result_norm$summary.fixed, 2) ## Range, standard deviation (spatial effect), and standard deviation (Gaussian) res_summary_hyper_rounded <- round(result_norm$summary.hyperpar, 2) ## Create a list of parameter marginals for visualization pmarginals <-    list(     data.frame(       param = \"sigma.e\",       inla.tmarginal(         function(x) exp(-x/2),         result_norm$internal.marginals.hyperpar$`Log precision for the Gaussian observations`)),     data.frame(       param = \"range\",       inla.tmarginal(         function(x) exp(x),         result_norm$internal.marginals.hyperpar$`Theta1 for i`)),     data.frame(       param = \"sigma\",       inla.tmarginal(         function(x) exp(x),         result_norm$internal.marginals.hyperpar$`Theta2 for i`))   )  ## Add true values to parameter marginals pmarginals[[1]]$true <- rep(sigma_e, length(pmarginals[[1]]$x)) pmarginals[[2]]$true <- rep(ranges[1], length(pmarginals[[1]]$x)) pmarginals[[3]]$true <- rep(1, length(pmarginals[[1]]$x)) ## Create a list of parameter marginals for visualization fmarginals <-    list(     data.frame(       param = \"intercept\",       value = result_norm$marginals.fixed$beta0     ),     data.frame(       param = \"depth\",       value = result_norm$marginals.fixed$beta1     )   )  ## Add true values to parameter marginals fmarginals[[1]]$true <- rep(beta0_norm, length(fmarginals[[1]]$value.x)) fmarginals[[2]]$true <- rep(beta1_norm, length(fmarginals[[2]]$value.y)) ## Add mean and standard deviation of the field to the grid  grid_sf[[1]]$u_mean <- as.vector( ## mean    inla.mesh.project(       gproj,        result_norm$summary.random$i$mean))  grid_sf[[1]]$u_sd <- exp(as.vector( ## standard deviation   inla.mesh.project(     gproj,      log(result_norm$summary.random$i$sd))))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"hyperparameters-posterior-distributions-1","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Marginals posterior distributions hyperparameters (red line represents true value)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"fixed-parameters-1","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Marginals posterior distributions fixed parameters (red line represents true value)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"simulated-vs-posterior-mean-of-the-random-field-1","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Simulated random field (u) compared posterior mean random field (u.mean)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"posterior-standard-deviation-of-the-field-1","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Posterior standard deviation random field observed points (black docs)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"prediction","dir":"Articles > Web","previous_headings":"Fit the barrier model > Spatial scenarios > Normal response variable","what":"Prediction","title":"Global oceanic barrier model on the sphere","text":"Another common objective models predict response variable unsampled locations. , share code predicting barrier model across Earth. Initially, must download depth values locations want predict. case, ‚Äôll utilize grid previously defined projecting random field. Next, set stack prediction. , response variable defined NA (available), replicate effects present stack estimation updated depth values. Lastly, merge stacks, combining estimation prediction. complete stack, can rerun model exclusively prediction, utilizing previously fitted results (adjust control.mode). end, extract predicted values model generate sf object visualization. Predicted response variable across entire domain","code":"## Extracting latitude and longitude from the defined grid locs_latlong_pred <- get_depth(data = as.data.frame( st_coordinates(grid_ll[[1]])))  ## Scale the depth values (to km units) and storing them in the 'depth' column locs_latlong_pred$depth <- as.vector(locs_latlong_pred$depth / 1000) ## Create an inla.stack object for prediction stk.pred <- inla.stack(   data = list(resp = NA), ## Placeholder for the response variable (to be predicted)   A = list(gproj$proj$A, 1, 1), ## Projection matrix for the spatial field and an intercept term   effects = list(i = 1:bmodel$mesh$n, ## Spatial random effect                  beta1 = locs_latlong_pred$depth,                  beta0 = rep(1, length(locs_latlong_pred$depth))), ## Intercept term   tag = \"pred\" ## Tag for the stack, indicating it is used for prediction )  ## Combine the original stack (stk) with the prediction stack (stk.pred) stk.full <- inla.stack(stk, stk.pred) ## Re-run the model set.seed(52134) res_pred <- inla(resp ~ 0 + beta0 + f(beta1, model = \"linear\") + f(i, model = bmodel), ## Formula                  data = inla.stack.data(stk.full), ## Stack                  control.mode = list(theta = result_norm$mode$theta, restart = FALSE), ##  Utilize the theta parameters obtained from the previously estimated spde model                  control.predictor = list(A = inla.stack.A(stk.full),                                           compute = TRUE),                  control.compute = list(return.marginals.predictor = TRUE),                  verbose = TRUE) ## Extracting the values of the response variable pred <- inla.stack.index(stk.full, \"pred\")$data pred_values <- res_pred$summary.fitted.values$mean[pred]  ## Creating a data frame with coordinates and predicted values data_raster_pred <- data.frame(x = st_coordinates(grid_ll)[,1],                                y = st_coordinates(grid_ll)[,2],                                pred = as.vector(pred_values) )  ## Creating an sf object for visualization in Mollweide projection data_pred <- st_as_sf(x = data_raster_pred,                       coords = c(\"x\",\"y\"),                       crs = crs_ll)  ## Transforming the sf object to the desired projection data_pred_mll <- st_transform(data_pred, crs = crs_vis)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"bernouilli-response-variable","dir":"Articles > Web","previous_headings":"Fit the barrier model > Spatial scenarios","what":"Bernouilli response variable","title":"Global oceanic barrier model on the sphere","text":"use code provided normal response variable fit Bernoulli distribution, slight modifications specify likelihood.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"inlabru-1","dir":"Articles > Web","previous_headings":"Fit the barrier model > Spatial scenarios > Bernouilli response variable","what":"INLABRU","title":"Global oceanic barrier model on the sphere","text":"First, establish components model indicate response variable follows Bernoulli distribution. fitted model, can observe get back results. First, check summary fixed effect hyperparameters. Summary posterior distribution fixed effects. Summary posterior distribution hyperparameters , compute marginals hyperparameters: ranges rr standard deviation spatial effect œÉ\\sigma. Likewise, can plot marginals fixed effects: intercept depth linear coefficients. can also visualize predicted random field. case, compute mean spatial field also standard deviation.","code":"## Specify the model formula model_ber <- y ~   ## Intercept   Intercept(1) +   ## Depth linear effect   bat(depth, model = \"linear\") +   ## Spatial effect   field(cbind(x_coord,y_coord,z_coord),         model = bmodel #The barrier model         )  ## Fit the Bayesian model using INLA set.seed(2353) result_ber <- bru(     model_ber, data_model_ber_t[data_model_ber_t$time == 1,][,-1],     family = \"binomial\",     options = list(         verbose = TRUE,         control.compute = list(cpo = TRUE))) ## Beta 0 (intercept) and Beta 1 (depth) res_summary_fixed_rounded <- round(result_ber$summary.fixed, 2) ## Range, standard deviation (spatial effect), and standard deviation (Gaussian) res_summary_hyper_rounded <- round(result_ber$summary.hyperpar, 2) ## Create a list of parameter marginals for visualization pmarginals <-    list(     data.frame(       param = \"range\",       inla.tmarginal(         function(x) exp(x),         result_ber$internal.marginals.hyperpar$`Theta1 for field`)),     data.frame(       param = \"sigma\",       inla.tmarginal(         function(x) exp(x),         result_ber$internal.marginals.hyperpar$`Theta2 for field`))   )  ## Add true values to parameter marginals pmarginals[[1]]$true <- rep(ranges[1], length(pmarginals[[1]]$x)) pmarginals[[2]]$true <- rep(1, length(pmarginals[[1]]$x)) ## Create a list of parameter marginals for visualization fmarginals <-    list(     data.frame(       param = \"intercept\",       value = result_ber$marginals.fixed$Intercept     ),     data.frame(       param = \"depth\",       value = result_ber$marginals.fixed$bat     )   )  ## Add true values to parameter marginals fmarginals[[1]]$true <- rep(beta0_ber, length(fmarginals[[1]]$value.x)) fmarginals[[2]]$true <- rep(beta1_ber, length(fmarginals[[2]]$value.y)) ## Add mean and standard deviation of the field to the grid  grid_sf[[1]]$u_mean <- as.vector( ## mean    inla.mesh.project(       gproj,        result_ber$summary.random$field$mean))  grid_sf[[1]]$u_sd <- exp(as.vector( ## standard deviation   inla.mesh.project(     gproj,      log(result_ber$summary.random$field$sd))))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"hyperparameters-posterior-distributions-2","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Marginals posterior distributions hyperparameters (red line represents true value)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"fixed-parameters-2","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Marginals posterior distributions fixed parameters (red line represents true value)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"simulated-vs-posterior-mean-of-the-random-field-2","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Simulated random field (u) compared posterior mean random field (u.mean)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"posterior-standard-deviation-of-the-field-2","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Posterior standard deviation random field observed points (black docs)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"inla-1","dir":"Articles > Web","previous_headings":"Fit the barrier model > Spatial scenarios > Bernouilli response variable","what":"INLA","title":"Global oceanic barrier model on the sphere","text":"following code fits model using INLA base code. accomplish , INLA stack initially created model response variable according specified formula. stack includes projector matrix (Alocs), spatial effect (), depth (beta1), intercept (beta0). fitted model, can observe get back results. First, check summary fixed effect hyperparameters. Summary posterior distribution fixed effects. Summary posterior distribution hyperparameters , compute marginals hyperparameters: ranges rr standard deviation spatial effect œÉ\\sigma. Likewise, can plot marginals fixed effects: intercept depth linear coefficients. can also visualize predicted random field. case, compute mean spatial field also standard deviation.","code":"## Create an INLA stack (stk) for modeling the response variable based on the specified formula and data stk <- inla.stack(   data = list(resp = data_model_ber_t[data_model_ber_t$time == 1,]$y), ## Response variable   A = list(Alocs_time[[1]], 1,1),  ## Projector matrix   effects = list(i = 1:bmodel$mesh$n, ## Spatial effect                  beta1 = data_model_ber_t[data_model_ber_t$time == 1,]$depth, ## Depth                   beta0 = rep(1,nrow(data_model_ber_t[data_model_ber_t$time == 1,])) ## Intercept   ),   tag = \"est\" ## Estimation stack (est) )  ## Use inla to fit the specified formula and obtain the result set.seed(52134) result_ber <- inla(resp ~ 0 + beta0 + f(beta1, model = \"linear\") + f(i, model = bmodel), ## Formula                data = inla.stack.data(stk), ## Stack                family = 'binomial',                control.predictor = list(A = inla.stack.A(stk),                                         compute = TRUE),                control.compute = list(return.marginals.predictor = TRUE),                verbose = TRUE) ## Beta 0 (intercept) and Beta 1 (depth) res_summary_fixed_rounded <- round(result_ber$summary.fixed, 2) ## Range, standard deviation (spatial effect), and standard deviation (Gaussian) res_summary_hyper_rounded <- round(result_ber$summary.hyperpar, 2) ## Create a list of parameter marginals for visualization pmarginals <-    list(     data.frame(       param = \"range\",       inla.tmarginal(         function(x) exp(x),         result_ber$internal.marginals.hyperpar$`Theta1 for i`)),     data.frame(       param = \"sigma\",       inla.tmarginal(         function(x) exp(x),         result_ber$internal.marginals.hyperpar$`Theta2 for i`))   )  ## Add true values to parameter marginals pmarginals[[1]]$true <- rep(ranges[1], length(pmarginals[[1]]$x)) pmarginals[[2]]$true <- rep(1, length(pmarginals[[1]]$x)) ## Create a list of parameter marginals for visualization fmarginals <-    list(     data.frame(       param = \"intercept\",       value = result_ber$marginals.fixed$beta0     ),     data.frame(       param = \"depth\",       value = result_ber$marginals.fixed$beta1     )   )  ## Add true values to parameter marginals fmarginals[[1]]$true <- rep(beta0_ber, length(fmarginals[[1]]$value.x)) fmarginals[[2]]$true <- rep(beta1_ber, length(fmarginals[[2]]$value.y)) ## Add mean and standard deviation of the field to the grid  grid_sf[[1]]$u_mean <- as.vector( ## mean    inla.mesh.project(       gproj,        result_ber$summary.random$i$mean))  grid_sf[[1]]$u_sd <- exp(as.vector( ## standard deviation   inla.mesh.project(     gproj,      log(result_ber$summary.random$i$sd))))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"hyperparameters-posterior-distributions-3","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Marginals posterior distributions hyperparameters (red line represents true value)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"fixed-parameters-3","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Marginals posterior distributions fixed parameters (red line represents true value)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"simulated-vs-posterior-mean-of-the-random-field-3","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Simulated random field (u) compared posterior mean random field (u.mean)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"posterior-standard-deviation-of-the-field-3","dir":"Articles > Web","previous_headings":"","what":"Global oceanic barrier model on the sphere","title":"Global oceanic barrier model on the sphere","text":"Posterior standard deviation random field observed points (black docs)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"prediction-1","dir":"Articles > Web","previous_headings":"Fit the barrier model > Spatial scenarios > Bernouilli response variable","what":"Prediction","title":"Global oceanic barrier model on the sphere","text":"Now, predict probability presence according fitted model. Next, set stack prediction. , respons variable defined NA (available), replicate effects present stack estimation updated depth values. Lastly, merge stacks, combining estimation prediction. complete stack, can rerun model exclusively prediction, utilizing previously fitted results (adjust control.mode). end, extract predicted values model generate sf object visualization. Predicted response variable across entire domain","code":"## Extracting latitude and longitude from the defined grid locs_latlong_pred <- get_depth(data = as.data.frame(    st_coordinates(grid_ll[[1]])))  ## Scale the depth values (km units) and storing them in the 'depth' column locs_latlong_pred$depth <- as.vector(locs_latlong_pred$depth / 1000) ## Create an inla.stack object for prediction stk.pred <- inla.stack(   data = list(resp = NA), ## Placeholder for the response variable (to be predicted)   A = list(gproj$proj$A, 1, 1), ## Projection matrix for the spatial field and an intercept term   effects = list(i = 1:bmodel$mesh$n, ## Spatial random effect                  beta1 = locs_latlong_pred$depth,                  beta0 = rep(1, length(locs_latlong_pred$depth))), ## Intercept term   tag = \"pred\" ## Tag for the stack, indicating it is used for prediction )  ## Combine the original stack (stk) with the prediction stack (stk.pred) stk.full <- inla.stack(stk, stk.pred) ## Re-run the model set.seed(52134) res_pred <- inla(resp ~ 0 + beta0 + f(beta1, model = \"linear\") + f(i, model = bmodel), ## Formula                  data = inla.stack.data(stk.full), ## Stack                  family = 'binomial',                  control.mode = list(theta = result_ber$mode$theta, restart = FALSE), ##  Utilize the theta parameters obtained from the previously estimated spde model                  control.predictor = list(A = inla.stack.A(stk.full),                                           compute = TRUE),                  control.compute = list(return.marginals.predictor = TRUE),                  verbose = TRUE) ## Extracting the values of the response variable pred <- inla.stack.index(stk.full, \"pred\")$data pred_values <- res_pred$summary.fitted.values$mean[pred] pred_values_presences <- boot::inv.logit(pred_values)  ## Creating a data frame with coordinates and predicted values data_raster_pred <- data.frame(x = st_coordinates(grid_ll)[,1],                                y = st_coordinates(grid_ll)[,2],                                pred = as.vector(pred_values_presences) )  ## Creating an sf object for visualization in Mollweide projection data_pred <- st_as_sf(x = data_raster_pred,                       coords = c(\"x\",\"y\"),                       crs = crs_ll)  ## Transforming the sf object to the desired projection data_pred_m <- st_transform(data_pred, crs = crs_vis)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"space-time-scenarios","dir":"Articles > Web","previous_headings":"Fit the barrier model","what":"Space-time scenarios","title":"Global oceanic barrier model on the sphere","text":"fitting predicting space, now going implement separable space-time model, illustrated Krainski et al., 2018. Essentially, include autoregressive model order 1 spatial effect. space examples, fit two different likelihoods (Gaussian Bernoulli). , displayed code, include autoregressive term order 1 model = ‚Äúar1‚Äù, probability parameter œÅ\\rho greater 0 0.9.","code":"## Define formula for the space-time effect rho.prior <- list(prior = 'pc.cor1', param = c(0, 0.9)) ## P(rho>0) = 0.9 form.barrier.st_ar1 <- y ~ 0 + intercept +   f(beta1, model = \"linear\") +   f(i, model = bmodel, group = time,     control.group = list(model = \"ar1\",                          hyper = list(theta = rho.prior)))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"normal-response-variable-1","dir":"Articles > Web","previous_headings":"Fit the barrier model > Space-time scenarios","what":"Normal response variable","title":"Global oceanic barrier model on the sphere","text":"code fitting spatio-temporal scenario almost spatial example; just include effect time projector matrix also stack. fitting, use inla function specify family ‚Äúgaussian‚Äù particular simulation. , can display main statistical measures estimation hyperparameters parameters. Summary posterior distribution fixed effects. Summary posterior distribution hyperparameters also compute marginal distribution hyperparameters parameters, can compare results obtained simulated case.","code":"## space-time projector matrix A.st_norm_t <- inla.spde.make.A(   mesh = smesh,   loc = cbind(data_model_norm_t$x_coord,               data_model_norm_t$y_coord,               data_model_norm_t$z_coord),   group = data_model_norm_t$time )  ## Stack data for modeling stk.st_norm_t <- inla.stack(   data = list(y = data_model_norm_t$y),   A = list(A.st_norm_t,1,1),   effects = list(     list(i = rep(1:bmodel$f$n, k),          time = rep(1:k, each = bmodel$f$n)),              beta1 = data_model_norm_t$depth,     intercept = rep(1, dim(data_model_norm_t)[1])   ) ) ## Fit spatial-temporal model with AR1 correlation structure result_ar1_norm <- inla(form.barrier.st_ar1,                    data = inla.stack.data(stk.st_norm_t),                    family = \"gaussian\",                    control.predictor = list(A = inla.stack.A(stk.st_norm_t),                                             compute = TRUE),                    control.compute = list(return.marginals.predictor = TRUE),                    verbose = TRUE) ## Print summary of fixed effects res_summary_fixed_rounded <- round(result_ar1_norm$summary.fixed, 2) knitr::kable(res_summary_fixed_rounded, caption = \"Summary of the posterior distribution of fixed effects.\") ## Print summary of hyperparameters res_summary_hyper_rounded <- round(result_ar1_norm$summary.hyperpar, 2) knitr::kable(res_summary_hyper_rounded, caption = \"Summary of the posterior distribution of hyperparameters\") ## Plot marginal posterior distributions of hyperparameters pmarginals <-    list(     data.frame(       param = \"range\",       inla.tmarginal(         function(x) exp(x),         result_ar1_norm$internal.marginals.hyperpar$`Theta1 for i`)),     data.frame(       param = \"sigma\",       inla.tmarginal(         function(x) exp(x),         result_ar1_norm$internal.marginals.hyperpar$`Theta2 for i`)),     data.frame(       param = \"sigma_e\",       inla.tmarginal(         function(x) exp(-x/2),         result_ar1_norm$internal.marginals.hyperpar$`Log precision for the Gaussian observations`)),     data.frame(       param = \"rho\",       inla.tmarginal(         function(x) 1/(1+exp(-x)),         result_ar1_norm$internal.marginals.hyperpar$`Group rho_intern for i`)),     data.frame(       param = \"intercept\",       value = result_ar1_norm$marginals.fixed$intercept     ),     data.frame(       param = \"beta1\",       value = result_ar1_norm$marginals.fixed$beta1     )   )  ## Add true values to parameter marginals pmarginals[[1]]$true <- rep(ranges[1], length(pmarginals[[1]]$x)) pmarginals[[2]]$true <- rep(sigma, length(pmarginals[[1]]$x)) pmarginals[[3]]$true <- rep(sigma_e, length(pmarginals[[1]]$x)) pmarginals[[4]]$true <- rep(rho, length(pmarginals[[1]]$x)) pmarginals[[5]]$true <- rep(beta0_norm, length(pmarginals[[5]]$value.x)) pmarginals[[6]]$true <- rep(beta1_norm, length(pmarginals[[5]]$value.x)) names(pmarginals[[5]]) <- c(\"param\", \"x\", \"y\", \"true\") names(pmarginals[[6]]) <- c(\"param\", \"x\", \"y\", \"true\")"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"parameter-and-hyperparameters-posterior-distributions","dir":"Articles > Web","previous_headings":"Fit the barrier model > Space-time scenarios > Normal response variable","what":"Parameter and hyperparameters posterior distributions","title":"Global oceanic barrier model on the sphere","text":"Posterior distribution parameters hyperparameters, , beta1 represents coefficient depth covariate, rho represents correlation parameter autoregressive model order 1, sigma represents standard deviation random field, sigma.e represents standard deviation Gaussian distribution.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"predited-random-fields","dir":"Articles > Web","previous_headings":"Fit the barrier model > Space-time scenarios > Normal response variable","what":"Predited random fields","title":"Global oceanic barrier model on the sphere","text":"Predicted random fields (u) years","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"bernouilli-response-variable-1","dir":"Articles > Web","previous_headings":"Fit the barrier model > Space-time scenarios","what":"Bernouilli response variable","title":"Global oceanic barrier model on the sphere","text":"framework Normal response variable can applied Bernoulli response variable. simply need change family inla function ‚Äúbinomial‚Äù. Consequently, obtain similar outputs, case, parameter interest probability. Summary posterior distribution fixed effects. Summary posterior distribution hyperparameters","code":"## space-time projector matrix A.st_ber_t <- inla.spde.make.A(   mesh = smesh,   loc = cbind(data_model_ber_t$x_coord,               data_model_ber_t$y_coord,               data_model_ber_t$z_coord),   group = data_model_ber_t$time )  ## Stack data for modeling stk.st_ber_t <- inla.stack(   data = list(y = data_model_ber_t$y),   A = list(A.st_ber_t,1,1),   effects = list(     list(i = rep(1:bmodel$f$n, k),          time = rep(1:k, each = bmodel$f$n)),              beta1 = data_model_ber_t$depth,     intercept = rep(1, dim(data_model_ber_t)[1])   ) )  ## Define formula for the space-time effect rho.prior <- list(prior = 'pc.cor1', param = c(0, 0.9)) ### P(rho>0) = 0.9 form.barrier.st_ar1 <- y ~ 0 + intercept +   f(beta1, model = \"linear\") +   f(i, model = bmodel, group = time,     control.group = list(model = \"ar1\",                          hyper = list(theta = rho.prior)))  ## Fit spatial-temporal model with AR1 correlation structure result_ar1_ber <- inla(form.barrier.st_ar1,                    data = inla.stack.data(stk.st_ber_t),                    family = \"binomial\",                    control.predictor = list(A = inla.stack.A(stk.st_ber_t),                                             compute = TRUE),                    control.compute = list(return.marginals.predictor = TRUE),                    verbose = TRUE)  ## Print summary of fixed effects res_summary_fixed_rounded <- round(result_ar1_ber$summary.fixed, 2) knitr::kable(res_summary_fixed_rounded, caption = \"Summary of the posterior distribution of fixed effects.\") ## Print summary of hyperparameters res_summary_hyper_rounded <- round(result_ar1_ber$summary.hyperpar, 2) knitr::kable(res_summary_hyper_rounded, caption = \"Summary of the posterior distribution of hyperparameters\") ## Plot marginal posterior distributions of hyperparameters pmarginals <-    list(     data.frame(       param = \"range\",       inla.tmarginal(         function(x) exp(x),         result_ar1_ber$internal.marginals.hyperpar$`Theta1 for i`)),     data.frame(       param = \"sigma\",       inla.tmarginal(         function(x) exp(x),         result_ar1_ber$internal.marginals.hyperpar$`Theta2 for i`)),     data.frame(       param = \"rho\",       inla.tmarginal(         function(x) 1/(1+exp(-x)),         result_ar1_ber$internal.marginals.hyperpar$`Group rho_intern for i`)),     data.frame(       param = \"intercept\",       value = result_ar1_ber$marginals.fixed$intercept     ),     data.frame(       param = \"beta1\",       value = result_ar1_ber$marginals.fixed$beta1     )   )  ## Add true values to parameter marginals pmarginals[[1]]$true <- rep(ranges[1], length(pmarginals[[1]]$x)) pmarginals[[2]]$true <- rep(sigma, length(pmarginals[[1]]$x)) pmarginals[[3]]$true <- rep(rho, length(pmarginals[[1]]$x)) pmarginals[[4]]$true <- rep(beta0_ber, length(pmarginals[[4]]$value.x)) pmarginals[[5]]$true <- rep(beta1_ber, length(pmarginals[[5]]$value.x)) names(pmarginals[[4]]) <- c(\"param\", \"x\", \"y\", \"true\") names(pmarginals[[5]]) <- c(\"param\", \"x\", \"y\", \"true\")"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"parameter-and-hyperparameters-posterior-distributions-1","dir":"Articles > Web","previous_headings":"Fit the barrier model > Space-time scenarios > Bernouilli response variable","what":"Parameter and hyperparameters posterior distributions","title":"Global oceanic barrier model on the sphere","text":"Posterior distribution parameters hyperparameters, , beta1 represents coefficient depth covariate, rho represents correlation parameter autoregressive model order 1, sigma represents standar deviation random field.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"predited-random-fields-1","dir":"Articles > Web","previous_headings":"Fit the barrier model > Space-time scenarios > Bernouilli response variable","what":"Predited random fields","title":"Global oceanic barrier model on the sphere","text":"Predicted random fields (u) years","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"session-information","dir":"Articles > Web","previous_headings":"","what":"Session information","title":"Global oceanic barrier model on the sphere","text":"","code":"## R version 4.5.2 (2025-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ##  [1] ggpubr_0.6.2             DOYPAColors_0.0.2        s2_1.1.9                 ##  [4] ggOceanMaps_2.2.0        INLAspacetime_0.1.12.013 INLAtools_0.0.5          ##  [7] inlabru_2.13.0           fmesher_0.5.0            ggplot2_4.0.1            ## [10] sf_1.0-22                rnaturalearth_1.1.0      rmarkdown_2.30           ## [13] knitr_1.50               INLA_25.11.22            Matrix_1.7-4             ##  ## loaded via a namespace (and not attached): ##  [1] gtable_0.3.6            xfun_0.54               bslib_0.9.0             ##  [4] rstatix_0.7.3           lattice_0.22-7          vctrs_0.6.5             ##  [7] tools_4.5.2             generics_0.1.4          spdep_1.4-1             ## [10] parallel_4.5.2          tibble_3.3.0            proxy_0.4-27            ## [13] pkgconfig_2.0.3         KernSmooth_2.23-26      RColorBrewer_1.1-3      ## [16] S7_0.2.1                desc_1.4.3              lifecycle_1.0.4         ## [19] deldir_2.0-4            compiler_4.5.2          farver_2.1.2            ## [22] MatrixModels_0.5-4      textshaping_1.0.4       carData_3.0-5           ## [25] stars_0.6-8             htmltools_0.5.8.1       class_7.3-23            ## [28] sass_0.4.10             yaml_2.3.10             Formula_1.2-5           ## [31] car_3.1-3               tidyr_1.3.1             pillar_1.11.1           ## [34] pkgdown_2.2.0           jquerylib_0.1.4         classInt_0.4-11         ## [37] cachem_1.1.0            wk_0.9.4                boot_1.3-32             ## [40] abind_1.4-8             rnaturalearthdata_1.0.0 Deriv_4.2.0             ## [43] tidyselect_1.2.1        digest_0.6.39           dplyr_1.1.4             ## [46] purrr_1.2.0             labeling_0.4.3          splines_4.5.2           ## [49] cowplot_1.2.0           fastmap_1.2.0           grid_4.5.2              ## [52] cli_3.6.5               magrittr_2.0.4          broom_1.0.10            ## [55] e1071_1.7-16            withr_3.0.2             backports_1.5.0         ## [58] scales_1.4.0            sp_2.2-0                spData_2.3.4            ## [61] gridExtra_2.3           ggsignif_0.6.4          ragg_1.5.0              ## [64] evaluate_1.0.5          rlang_1.1.6             Rcpp_1.1.0              ## [67] glue_1.8.0              DBI_1.2.3               jsonlite_2.0.0          ## [70] plyr_1.8.9              R6_2.6.1                systemfonts_1.3.1       ## [73] fs_1.6.6                units_1.0-0"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/barrier_global.html","id":"references","dir":"Articles > Web","previous_headings":"","what":"References","title":"Global oceanic barrier model on the sphere","text":"Bakka, H., J. Vanhatalo, J. Illian, D. Simpson, H. Rue. 2019. ‚ÄúNon-Stationary Gaussian Models Physical Barriers.‚Äù Spatial Statistics 29 (March): 268‚Äì88. https://doi.org/https://doi.org/10.1016/j.spasta.2019.01.002. Lindgren, Finn, H√•vard Rue, Johan Lindstr√∂m. 2011. ‚ÄúExplicit Link Gaussian Fields Gaussian Markov Random Fields: Stochastic Partial Differential Equation Approach.‚Äù Journal Royal Statistical Society: Series B (Statistical Methodology) 73 (4): 423‚Äì98. https://doi.org/10.1111/j.1467-9868.2011.00777.x. Krainski, E., G√≥mez-Rubio, V., Bakka, H., Lenzi, ., Castro-Camilo, D., Simpson, D., Lindgren, F. Rue, H. (2018). Advanced spatial modeling stochastic partial differential equations using R INLA. Chapman Hall/CRC.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/piemonte.html","id":"abstract","dir":"Articles > Web","previous_headings":"","what":"Abstract","title":"The Piemonte dataset example","text":"vignette illustrate fit spacetime models Lindgren et al. (2024), see [SORT vol.¬†48, . 1, pp.¬†3-66] related code, data analysed Cameletti et al. (2013). perform use Bayesian paradigm theINLA package, using features provided inlabru package facilitate coding.","code":""},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/piemonte.html","id":"the-packages-and-setup","dir":"Articles > Web","previous_headings":"Introduction","what":"The packages and setup","title":"The Piemonte dataset example","text":"start loading required packages visualizations, ggplot2 patchwork packages. ask return WAIC, DIC CPO","code":"library(ggplot2) library(patchwork) library(INLA) #> Loading required package: Matrix #> This is INLA_25.11.22 built 2025-11-22 08:57:21 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - List available models/likelihoods/etc with inla.list.models() #>  - Use inla.doc(<NAME>) to access documentation library(INLAspacetime) #> Loading required package: fmesher #> Loading required package: INLAtools #> Loading required package: inlabru #> see more at https://eliaskrainski.github.io/INLAspacetime library(inlabru) library(fmesher) ctrc <- list(   waic = TRUE,   dic = TRUE,   cpo = TRUE)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/piemonte.html","id":"getting-the-dataset","dir":"Articles > Web","previous_headings":"Introduction","what":"Getting the dataset","title":"The Piemonte dataset example","text":"use dataset analysed Cameletti et al. (2013), can downloaded follows. First, set filenames Download read borders file Download read coordinates file Download read dataset Inspect dataset Prepare time used Standardize covariates used data analysis define dataset including needed information outcome log PM10, used Cameletti et al. (2013).","code":"u0 <- paste0(     \"http://inla.r-inla-download.org/\",     \"r-inla.org/case-studies/Cameletti2012/\") coofl <- \"coordinates.csv\" datafl <- \"Piemonte_data_byday.csv\" bordersfl <- \"Piemonte_borders.csv\" ### get the domain borders if(!file.exists(bordersfl))     download.file(paste0(u0, bordersfl), bordersfl) dim(pborders <- read.csv(bordersfl)) #> [1] 27821     2 ### get the coordinates if(!file.exists(coofl))     download.file(paste0(u0, coofl), coofl) dim(locs <- read.csv(coofl)) #> [1] 24  3 ### get the dataset if(!file.exists(datafl))     download.file(paste0(u0, datafl), datafl) dim(pdata <- read.csv(datafl)) #> [1] 4368   11 head(pdata) #>   Station.ID     Date     A   UTMX    UTMY   WS   TEMP   HMIX PREC   EMI PM10 #> 1          1 01/10/05  95.2 469.45 4972.85 0.90 288.81 1294.6    0 26.05   28 #> 2          2 01/10/05 164.1 423.48 4950.69 0.82 288.67 1139.8    0 18.74   22 #> 3          3 01/10/05 242.9 490.71 4948.86 0.96 287.44 1404.0    0  6.28   17 #> 4          4 01/10/05 149.9 437.36 4973.34 1.17 288.63 1042.4    0 29.35   25 #> 5          5 01/10/05 405.0 426.44 5045.66 0.60 287.63 1038.7    0 32.19   20 #> 6          6 01/10/05 257.5 394.60 5001.18 1.02 288.59 1048.3    0 34.24   41 range(pdata$Date <- as.Date(pdata$Date, \"%d/%m/%y\")) #> [1] \"2005-10-01\" \"2006-03-31\" pdata$time <- as.integer(difftime(     pdata$Date, min(pdata$Date), units = \"days\")) + 1 ### prepare the covariates xnames <- c(\"A\", \"WS\", \"TEMP\", \"HMIX\", \"PREC\", \"EMI\") xmean <- colMeans(pdata[, xnames]) xsd <- sapply(pdata[xnames], sd)  ### prepare the data (st loc, scale covariates and log PM10) dataf <- data.frame(pdata[c(\"UTMX\", \"UTMY\", \"time\")],                     scale(pdata[xnames], xmean, xsd),                     y = log(pdata$PM10)) str(dataf) #> 'data.frame':    4368 obs. of  10 variables: #>  $ UTMX: num  469 423 491 437 426 ... #>  $ UTMY: num  4973 4951 4949 4973 5046 ... #>  $ time: num  1 1 1 1 1 1 1 1 1 1 ... #>  $ A   : num  -1.3956 -0.7564 -0.0254 -0.8881 1.4785 ... #>  $ WS  : num  -0.0777 -0.2319 0.038 0.4429 -0.6561 ... #>  $ TEMP: num  2.1 2.07 1.82 2.06 1.86 ... #>  $ HMIX: num  2.18 1.69 2.53 1.38 1.37 ... #>  $ PREC: num  -0.29 -0.29 -0.29 -0.29 -0.29 ... #>  $ EMI : num  -0.1753 -0.3454 -0.6353 -0.0985 -0.0324 ... #>  $ y   : num  3.33 3.09 2.83 3.22 3 ..."},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/piemonte.html","id":"the-data-model-definition","dir":"Articles > Web","previous_headings":"","what":"The data model definition","title":"The Piemonte dataset example","text":"consider following linear mixed model outcome ùê≤=ùêñùõÉ+ùêÄùêÆ+ùêû  \\mathbf{y} = \\mathbf{W}\\mathbf{\\beta} + \\mathbf{}\\mathbf{u} + \\mathbf{e}  Œ≤\\beta fixed effects, regression coefficients including intercept, matrix covariates ùêñ\\mathbf{W}, ùêÆ\\mathbf{u} spatio-temporal random effect matrix ùêÄ\\mathbf{} projector matrix discretized domain data. spatio-temporal random effect ùêÆ\\mathbf{u} defined continuous spacetime domain discretized considering meshes time space. difference Cameletti et al. (2013) now use models Lindgren et al. (2024) ùêÆ\\mathbf{u}. Define temporal mesh, knot spaced h, h = 1 means one per day. Define spatial mesh, used Cameletti et al. (2013). Visualize spatial mesh, border locations.  set prior likelihood precision considering PC-prior, Simpson et al. (2017), following probabilistic statements: P(œÉe>UœÉe\\sigma_e > U_{\\sigma_e}) = Œ±œÉe\\alpha_{\\sigma_e}, using UœÉeU_{\\sigma_e} = 1 Œ±œÉe=0.05\\alpha_{\\sigma_e} = 0.05. inlabru can define likelihood model like() function use fitting models different linear predictors later. linear predictor, right-rand side formula, can defined using expression models going fit ","code":"nt <- max(pdata$time) h <- 1 tmesh <- fm_mesh_1d(   loc = seq(1, nt + h/2, h),    degree = 1) tmesh$n #> [1] 182 smesh <- fm_mesh_2d(     cbind(locs[,2], locs[,3]),     loc.domain = pborders,     max.edge = c(50, 300),     offset = c(10, 140),     cutoff = 5,     min.angle = c(26, 21)) smesh$n #> [1] 142 par(mfrow = c(1,1), mar = c(0,0,1,0)) plot(smesh, asp = 1) lines(pborders, lwd = 2, col = \"green4\") points(locs[, 2:3], pch = 19, col = \"blue\") lkprec <- list(     prec = list(prior = \"pcprec\", param = c(1, 0.05))) lhood <- like(   formula = y ~ .,   family = \"gaussian\",   control.family = list(     hyper = lkprec),   data = dataf) M <- ~ -1 + Intercept(1) + A + WS + TEMP + HMIX + PREC + EMI +     field(list(space = cbind(UTMX, UTMY),                 time = time),           model = stmodel)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/piemonte.html","id":"the-spacetime-models","dir":"Articles > Web","previous_headings":"","what":"The spacetime models","title":"The Piemonte dataset example","text":"implementation spacetime model uses cgeneric interface INLA, see documentation details. Therefore C code mainly build precision matrix compute model parameter priors compiled static library. code included INLAspacetime package also copied INLA package compiled compilers order avoid possible mismatches. order use , define matrices vectors needed, including prior parameter definitions. class models Lindgren et al. (2024) spatial range, temporal range marginal standard deviation parameters. consider PC-prior, Fuglstad et al. (2017), parameters defined probability statements: P(rs<Ursr_s<U_{r_s})=Œ±rs\\alpha_{r_s}, P(rt<Urtr_t<U_{r_t})=Œ±rt\\alpha_{r_t} P(œÉ<UœÉ\\sigma<U_{\\sigma})=Œ±œÉ\\alpha_{\\sigma}. consider Urs=100U_{r_s}=100, Urt=5U_{r_t}=5 UœÉ=2U_{\\sigma}=2. Œ±rs=Œ±rt=Œ±œÉ=0.05\\alpha_{r_s}=\\alpha_{r_t}=\\alpha_{\\sigma}=0.05 selection one models Lindgren et al. (2024) chosing Œ±t\\alpha_t, Œ±s\\alpha_s Œ±e\\alpha_e integer numbers. start considering model Œ±t=1\\alpha_t=1, Œ±s=0\\alpha_s=0 Œ±t=2\\alpha_t=2, model separable spatio-temporal covariance, fit models later.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/piemonte.html","id":"defining-a-particular-model","dir":"Articles > Web","previous_headings":"The spacetime models","what":"Defining a particular model","title":"The Piemonte dataset example","text":"define object needed use function stModel.define() model selected considering values Œ±t\\alpha_t, Œ±s\\alpha_s Œ±e\\alpha_e collapsed. order illustrate done, can set overall integrate--zero constraint, need helps model components identification. uses weights based mesh node volumes, temporal spatial meshes. can set automatically defining model adding constr = TRUE. Initial values hyper-parameters help fit models less computing time. also important consider light dataset parameter scale. example, consider spatial domain within box around 203.7203.7 266.5266.5 kilometers, already building mesh setting prior rsr_s. can set initial values log parameters take less iterations converge: code fit model inlabru Summary posterior marginal distributions fixed effects hyperparameters, transform posterior marginal distributions model hyperparameters ones computed internal scale, log(1/œÉe2)\\log(1/\\sigma^2_e), log(rs)\\log(r_s), log(rt)\\log(r_t) log(œÉ)\\log(\\sigma), user scale parametrization, œÉe\\sigma_e, rsr_s, rtr_t œÉ\\sigma, respectivelly. compute show summary However, better look posterior marginal , visualize later. model fitted Cameletti et al. (2013) includes two covariates setup model discrete temporal domain temporal correlation modeled first order autoregression parameter œÅ\\rho. fitted model defined considering continuous temporal domain range parameter rsr_s. However, first order autocorrelation taken œÅ=exp(‚àíh8ŒΩ/rs)\\rho = \\exp(-h\\sqrt{8\\nu}/r_s), hh temporal resolution used temporal mesh ŒΩ\\nu equal 0.50.5 fitted model. can compare ou results Table 3 Cameletti et al. (2013) ","code":"model <- \"102\" stmodel <- stModel.define(     smesh, tmesh, model,     control.priors = list(         prs = c(150, 0.05),         prt = c(10, 0.05),         psigma = c(5, 0.05)),     constr = TRUE) theta.ini <- c(4, 7, 7, 1) fit102 <-      bru(M,         lhood,         options = list(             control.mode = list(theta = theta.ini, restart = TRUE),             control.compute = ctrc)) fit102$summary.fixed[, c(1, 2, 3, 5)] #>                  mean          sd   0.025quant   0.975quant #> Intercept  3.73693823 0.246316017  3.250885642  4.222649422 #> A         -0.17937607 0.050020482 -0.278529488 -0.081343508 #> WS        -0.06042592 0.008441734 -0.076969497 -0.043860832 #> TEMP      -0.12239581 0.035188018 -0.191467942 -0.053459337 #> HMIX      -0.02373568 0.013204746 -0.049591522  0.002198076 #> PREC      -0.05355159 0.008606716 -0.070414235 -0.036658128 #> EMI        0.03629578 0.015193521  0.006137179  0.065808696 post.h <- list(   sigma_e = inla.tmarginal(function(x) exp(-x/2),                             fit102$internal.marginals.hyperpar[[1]]),   range_s = inla.tmarginal(function(x) exp(x),                             fit102$internal.marginals.hyperpar[[2]]),   range_t = inla.tmarginal(function(x) exp(x),                             fit102$internal.marginals.hyperpar[[3]]),   sigma_u = inla.tmarginal(function(x) exp(x),                             fit102$internal.marginals.hyperpar[[4]]) ) shyper <- t(sapply(post.h, function(m)    unlist(inla.zmarginal(m, silent = TRUE)))) shyper[, c(1, 2, 3, 7)] #>                mean           sd  quant0.025  quant0.975 #> sigma_e   0.1810037  0.003772596   0.1737315   0.1885476 #> range_s 280.5962223 17.069613244 248.7725665 315.7921834 #> range_t  49.9090614  8.174251999  36.0540431  68.0831369 #> sigma_u   1.1371070  0.087445832   0.9778042   1.3210244 c(shyper[c(1, 4, 2), 1],    a = exp(-h * sqrt(8 * 0.5) / shyper[3, 1])) #>     sigma_e     sigma_u     range_s           a  #>   0.1810037   1.1371070 280.5962223   0.9607194"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/piemonte.html","id":"comparing-different-models","dir":"Articles > Web","previous_headings":"","what":"Comparing different models","title":"The Piemonte dataset example","text":"now fit model 121121 uu well, use code building model matrices use code fitting follows join fits list object make easier working computing time model fit number fn-calls optimization posterior mode parameter model (internal scale) compute posterior marginal distribution hyper-parameters user-interpretable scale, like first model, Join make visualization easier  comparison model parameters ùêÆ\\mathbf{u} different models done light covariance functions illustrated Lindgren et al. (2024). fitted œÉe\\sigma_e different models comparable can see considering model 121121 ùêÆ\\mathbf{u}, posterior marginal concentrated values lower considering model 102102. can look posterior mean uu models see model ‚Äò121‚Äô wider spread.  can also check fitting statistics DIC, WAIC, negative log probability ordinates (LPO) cross-validated version (LCPO), summarized mean.","code":"model <- \"121\" stmodel <- stModel.define(     smesh, tmesh, model,     control.priors = list(         prs = c(150, 0.05),         prt = c(10, 0.05),         psigma = c(5, 0.05)),     constr = TRUE) fit121 <-      bru(M,         lhood,         options = list(             control.mode = list(theta = theta.ini, restart = TRUE),             control.compute = ctrc)) results <- list(\"u102\" = fit102, \"u121\" = fit121) sapply(results, function(r) r$cpu.used) #>                u102        u121 #> Pre       0.4544694   0.3488176 #> Running 134.8050725 254.6783457 #> Post      4.2852588   2.8637428 #> Total   139.5448008 257.8909061 sapply(results, function(r) r$misc$nfunc) #> u102 u121  #>  318  401 sapply(results, function(r) r$mode$theta) #>                                                  u102      u121 #> Log precision for the Gaussian observations 3.4195705  3.594098 #> Theta1 for field                            5.6333676  7.291771 #> Theta2 for field                            3.8846603 10.982427 #> Theta3 for field                            0.1203597  2.155461 posts.h2 <- lapply(1:2, function(m) vector(\"list\", 4L)) for(m in 1:2) {     posts.h2[[m]]$sigma_e =         data.frame(         parameter = \"sigma_e\",          inla.tmarginal(           function(x) exp(-x/2),            results[[m]]$internal.marginals.hyperpar[[1]]))     for(p in 2:4) {       posts.h2[[m]][[p]] <-          data.frame(         parameter = c(NA, \"range_s\", \"range_t\", \"sigma_u\")[p],          inla.tmarginal(           function(x) exp(x),            results[[m]]$internal.marginals.hyperpar[[p]])       )     } } posts.df <- rbind(   data.frame(model = \"102\", do.call(rbind, posts.h2[[1]])),   data.frame(model = \"121\", do.call(rbind, posts.h2[[2]])) )  ggplot(posts.df) +   geom_line(aes(x = x, y = y, group = model, color = model)) +   ylab(\"Density\") + xlab(\"\") +    facet_wrap(~parameter, scales = \"free\") par(mfrow = c(1, 1), mar = c(3, 3, 0, 0.0), mgp = c(2, 1, 0)) uu.hist <- lapply(results, function(r)     hist(r$summary.random$field$mean,          -60:60/20, plot = FALSE)) ylm <- range(uu.hist[[1]]$count, uu.hist[[2]]$count) plot(uu.hist[[1]], ylim = ylm,      col = rgb(1, 0.1, 0.1, 1.0), border = FALSE,       xlab = \"u\", main = \"\") plot(uu.hist[[2]], add = TRUE, col = rgb(0.1, 0.1, 1, 0.5), border = FALSE) legend(\"topleft\", c(\"separable\", \"non-separable\"),         fill = rgb(c(1,0.1), 0.1, c(0.1, 1), c(1, 0.5)),         border = 'transparent', bty = \"n\") t(sapply(results, function(r) {   c(DIC = mean(r$dic$local.dic, na.rm = TRUE),     WAIC = mean(r$waic$local.waic, na.rm = TRUE),     LPO = -mean(log(r$po$po), na.rm = TRUE),      LCPO = -mean(log(r$cpo$cpo), na.rm = TRUE)) })) #>             DIC       WAIC        LPO       LCPO #> u102 -0.3768010 -0.2596477 -0.4054261 -0.1174270 #> u121 -0.4110888 -0.3528269 -0.5082013 -0.1158488"},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/web/piemonte.html","id":"the-automatic-group-leave-out-cross-validation","dir":"Articles > Web","previous_headings":"","what":"The automatic group-leave-out cross validation","title":"The Piemonte dataset example","text":"One may interested evaluating model prediction. leave-one-strategy already available INLA since several years ago, see Held, Schrodle, Rue (2010) details. Recently, automatic group cross validation strategy implemented, see Liu Rue (2023) details. can inspect detected observations posterior linear predictor correlated one, including . 100th observation model ‚Äú102‚Äù result model ‚Äú121‚Äù intersection , model setup used. can check observations dataset found locations nearby time. can compute negative mean log score lower number better","code":"g5cv <- lapply(   results, inla.group.cv, num.level.sets = 5,    strategy = \"posterior\", size.max = 50) g5cv$u102$group[[100]] #> $idx #> [1]  52  76  98 100 106 124 #>  #> $corr #> [1] 0.2574879 0.4289277 0.3003505 1.0000000 0.3298707 0.4289277 g5cv$u121$group[[100]] #> $idx #> [1]  52  76  98 100 124 148 #>  #> $corr #> [1] 0.1659362 0.3725930 0.1659362 1.0000000 0.3749559 0.1619523 dataf[g5cv$u102$group[[100]]$idx, ] #>       UTMX    UTMY time          A           WS     TEMP       HMIX       PREC #> 52  437.36 4973.34    3 -0.8881265  0.982687762 1.077344 -0.6959771 1.94505331 #> 76  437.36 4973.34    4 -0.8881265  0.674216318 1.297701  0.9479287 3.70037355 #> 98  423.48 4950.69    5 -0.7563919 -0.578948923 1.387847 -0.4413098 0.08590275 #> 100 437.36 4973.34    5 -0.8881265  0.770613644 1.441935  0.2530248 0.16426526 #> 106 416.65 4985.65    5  0.3225334 -0.000564966 1.397863  1.1608209 0.63052220 #> 124 437.36 4973.34    6 -0.8881265  0.751334179 1.618220  1.0845756 0.03692618 #>             EMI        y #> 52  -0.01821338 2.564949 #> 76  -0.01542101 2.708050 #> 98  -0.27115486 2.484907 #> 100  0.01622576 2.890372 #> 106 -0.61950205 2.708050 #> 124  0.02599903 2.995732 sapply(g5cv, function(r) -mean(log(r$cv), na.rm = TRUE)) #>       u102       u121  #> 0.08181355 0.11349366"},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/articles/website_examples.html","id":"vignettes","dir":"Articles","previous_headings":"","what":"Vignettes","title":"Vignettes on the INLAspacetime website","text":"potentially long running examples/tutorials available (https://eliaskrainski.github.io/INLAspacetime/) Global oceanic barrier model sphere barrier model illustration Piemonte dataset example","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Elias Teixeira Krainski. Maintainer, author, copyright holder. Finn Lindgren. Author. Haavard Rue. Author.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Krainski E, Lindgren F, Rue H (2025). INLAspacetime: Spatial Spatio-Temporal Models using 'INLA'. R package version 0.1.12.013, https://github.com/eliaskrainski/INLAspacetime.","code":"@Manual{,   title = {INLAspacetime: Spatial and Spatio-Temporal Models using 'INLA'},   author = {Elias Teixeira Krainski and Finn Lindgren and Haavard Rue},   year = {2025},   note = {R package version 0.1.12.013},   url = {https://github.com/eliaskrainski/INLAspacetime}, }"},{"path":"https://eliaskrainski.github.io/INLAspacetime/index.html","id":"inlaspacetime","dir":"","previous_headings":"","what":"Spatial and Spatio-Temporal Models using INLA","title":"Spatial and Spatio-Temporal Models using INLA","text":"R package implement certain spatial spatio-temporal models, including spatio-temporal models proposed SORT vol.¬†48, . 1, pp.¬†3-66. uses cgeneric interface INLA package, implement models writing C code build precision matrix compiling INLA can use internally.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/index.html","id":"we-have-implemented","dir":"","previous_headings":"","what":"We have implemented","title":"Spatial and Spatio-Temporal Models using INLA","text":"models presented diffusion-based spatio-temporal extension Gaussian Mat√©rn fields (2024). Finn Lindgren, Haakon Bakka, David Bolin, Elias Krainski H√•vard Rue. SORT vol.¬†48, . 1, pp.¬†3-66. (https://raco.cat/index.php/SORT/article/view/428665) barrier (transparent barriers) model proposed https://doi.org/10.1016/j.spasta.2019.01.002","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Spatial and Spatio-Temporal Models using INLA","text":"Please check ","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial and Spatio-Temporal Models using INLA","text":"‚ÄòINLA‚Äô package suggested one, need actually fitting model. can install can install current CRAN version INLAspacetime: can install latest version INLAspacetime GitHub ","code":"install.packages(\"INLA\",repos=c(getOption(\"repos\"),INLA=\"https://inla.r-inla-download.org/R/testing\"), dep=TRUE) install.packages(\"INLAspacetime\") ## install.packages(\"remotes\") remotes::install_github(\"eliaskrainski/INLAspacetime\",  build_vignettes=TRUE)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/index.html","id":"a-spacetime-example","dir":"","previous_headings":"","what":"A spacetime example","title":"Spatial and Spatio-Temporal Models using INLA","text":"Simulate fake data. Loading packages: Define spatial temporal discretization meshes Define spacetime model object used","code":"set.seed(1) n <- 5 dataf <- data.frame(     s1   = runif(n, -1, 1),     s2   = runif(n, -1, 1),     time = runif(n, 1, 4),     y    = rnorm(n, 0, 1)) str(dataf) #> 'data.frame':    5 obs. of  4 variables: #>  $ s1  : num  -0.469 -0.256 0.146 0.816 -0.597 #>  $ s2  : num  0.797 0.889 0.322 0.258 -0.876 #>  $ time: num  1.62 1.53 3.06 2.15 3.31 #>  $ y   : num  -0.00577 2.40465 0.76359 -0.79901 -1.14766 library(fmesher) library(INLA) library(INLAspacetime) #> see more on https://eliaskrainski.github.io/INLAspacetime smesh <- fm_mesh_2d(   loc = cbind(0,0),    max.edge = 5,    offset = 2) tmesh <- fm_mesh_1d(   loc = 0:5) stmodel <- stModel.define(     smesh = smesh, ## spatial mesh     tmesh = tmesh, ## temporal mesh     model = '121', ## model, see the paper     control.priors = list(         prs = c(1, 0.1), ## P(spatial range < 1) = 0.1         prt = c(5, 0), ## temporal range fixed to 5         psigma = c(1, 0.1) ## P(sigma > 1) = 0.1         )     )"},{"path":"https://eliaskrainski.github.io/INLAspacetime/index.html","id":"fit-the-model","dir":"","previous_headings":"","what":"Fit the model","title":"Spatial and Spatio-Temporal Models using INLA","text":"Define projector matrix spatial temporal meshes data , equivalently, fmesher methods tensor product spaces: Create ‚Äòfake‚Äô column used index. f() term Setting likelihood precision (fixed) Combine ‚Äòfake‚Äô index column .local Call main INLA function: Posterior marginal summaries fixed effect model parameters fixed.","code":"Aproj <- inla.spde.make.A(     mesh = smesh,     loc = cbind(dataf$s1, dataf$s2),     group = dataf$time,     group.mesh = tmesh ) Aproj <- fm_basis(   fm_tensor(list(space = smesh, time = tmesh)),   loc = list(     space = cbind(dataf$s1, dataf$s2),     time = dataf$time   ) ) dataf$st <- NA ctrl.lik <- list(   hyper = list(     prec = list(       initial = 10,        fixed = TRUE)       ) ) fmodel <- y ~ f(st, model = stmodel, A.local = Aproj) fit <- inla(     formula = fmodel,     data = dataf,     control.family = ctrl.lik) fit$summary.fixed #>                  mean       sd 0.025quant  0.5quant 0.975quant      mode #> (Intercept) 0.6934075 4.032682  -6.962392 0.5227421   9.417461 0.5550903 #>                      kld #> (Intercept) 7.405581e-05 fit$summary.hyperpar #>                   mean        sd 0.025quant 0.5quant 0.975quant      mode #> Theta1 for st 1.199208 0.4918283  0.3653922 1.161532   2.277316 0.9750207 #> Theta2 for st 1.435517 0.1710709  1.1031068 1.434032   1.776675 1.4277508"},{"path":"https://eliaskrainski.github.io/INLAspacetime/index.html","id":"using-the-inlabru","dir":"","previous_headings":"","what":"Using the inlabru","title":"Spatial and Spatio-Temporal Models using INLA","text":"Setting observation (likelihood) model object Define data model: linear predictor terms Fitting Summary model parameters Note: default prior intercept inlabru smaller variance default INLA, explains slight difference results.","code":"library(inlabru) data_model <- bru_obs(   formula = y ~ .,    family = \"gaussian\",   control.family = ctrl.lik,    data = dataf) linpred <- ~ 1 +     field(list(space = cbind(s1, s2),                 time = time),           model = stmodel) result <- bru(   components = linpred,   data_model) result$summary.fixed #>                mean       sd 0.025quant  0.5quant 0.975quant      mode #> Intercept 0.6690758 3.969868  -6.886579 0.5095548   9.213222 0.5379881 #>                    kld #> Intercept 5.712418e-05 result$summary.hyperpar #>                      mean        sd 0.025quant 0.5quant 0.975quant      mode #> Theta1 for field 1.190358 0.4867880   0.362423 1.153755   2.255714 0.9726899 #> Theta2 for field 1.435283 0.1709765   1.103480 1.433658   1.776675 1.4267684"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Earth_poly.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to define the boundary Earch polygon in longlat projection for a given resolution. ‚Äî Earth_poly","title":"Function to define the boundary Earch polygon in longlat projection for a given resolution. ‚Äî Earth_poly","text":"Function define boundary Earch polygon longlat projection given resolution.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Earth_poly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to define the boundary Earch polygon in longlat projection for a given resolution. ‚Äî Earth_poly","text":"","code":"Earth_poly(resol = 300, crs = \"+proj=moll +units=km\")"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Earth_poly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to define the boundary Earch polygon in longlat projection for a given resolution. ‚Äî Earth_poly","text":"resol number subdivisions along latitude coordinates half number subdivisions along longitude coordinates. crs string projection. Default Mollweide projection units kilometers.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Earth_poly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to define the boundary Earch polygon in longlat projection for a given resolution. ‚Äî Earth_poly","text":"'st_sfc' object Earth polygon.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/INLAspacetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial and Spatio-Temporal Models using INLA ‚Äî INLAspacetime","title":"Spatial and Spatio-Temporal Models using INLA ‚Äî INLAspacetime","text":"package main purpose provide user friendly functions fit temporal, spatial space-time models using INLA software available www.r-inla.org well inlabru package available","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/INLAspacetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial and Spatio-Temporal Models using INLA ‚Äî INLAspacetime","text":"","code":"INLAspacetime()"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/INLAspacetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial and Spatio-Temporal Models using INLA ‚Äî INLAspacetime","text":"opens Vignettes directory browser","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Jmatrices.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2nd order temporal matrices with boundary correction ‚Äî Jmatrices","title":"The 2nd order temporal matrices with boundary correction ‚Äî Jmatrices","text":"2nd order temporal matrices boundary correction","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Jmatrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2nd order temporal matrices with boundary correction ‚Äî Jmatrices","text":"","code":"Jmatrices(tmesh)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Jmatrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2nd order temporal matrices with boundary correction ‚Äî Jmatrices","text":"tmesh Temporal mesh","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Jmatrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2nd order temporal matrices with boundary correction ‚Äî Jmatrices","text":"return list temporal finite element method matrices supplied mesh.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Jmatrices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The 2nd order temporal matrices with boundary correction ‚Äî Jmatrices","text":"Temporal GMRF representation stationary boundary conditions Appendix E Lindgren et. al. (2024).","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Plot.html","id":null,"dir":"Reference","previous_headings":"","what":"To visualize time series over space. ‚Äî stlines","title":"To visualize time series over space. ‚Äî stlines","text":"visualize time series space.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"To visualize time series over space. ‚Äî stlines","text":"","code":"stlines(   stdata,   spatial,   group = NULL,   nmax.group = NULL,   xscale = 1,   yscale = 1,   colour = NULL,   ... )  stpoints(   stdata,   spatial,   group = NULL,   nmax.group = NULL,   xscale = 1,   yscale = 1,   colour = NULL,   ... )"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"To visualize time series over space. ‚Äî stlines","text":"stdata matrix data, column location. spatial object one class defined sp package. group integer vector indicating spatial unit time series belongs . Default NULL assumed time series belongs o spatial unit. nmax.group integer indicating maximum number time series plotted spatial unit. Default NULL, drawn. xscale numeric define scaling factor horizontal direction. yscale numeric define scaling factor vertical direction. colour color (may vector, one time series). Default NULL generate colors considering average time series. automatic colors defined using rgb() function alpha=0.5. considers relative rank time series mean, r. r used red,  1-r used blue triangular function, 1-2*|1-r/2|, considered green. , time series mean among lowest time series averages shown blue among highest temperatures shown red. transition blue red goes intermediate ones shown light green. ... arguments passed lines function.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"To visualize time series over space. ‚Äî stlines","text":"add lines existing plot","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"To visualize time series over space. ‚Äî stlines","text":"Scaling times series needed drawing map. area bounding box spatial object divided number locations standard scaling factor. multiplied user given xcale yscale.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Plot.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"To visualize time series over space. ‚Äî stlines","text":"stlines(): time series map centered location. stpoints(): time series map centered location.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/Plot.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"To visualize time series over space. ‚Äî stlines","text":"many geographical locations, look good","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2cov.html","id":null,"dir":"Reference","previous_headings":"","what":"Illustrative code to compute the covariance of the second order autoregression (AR2) model. ‚Äî ar2cov","title":"Illustrative code to compute the covariance of the second order autoregression (AR2) model. ‚Äî ar2cov","text":"Computes auto-covariance given coefficients.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2cov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Illustrative code to compute the covariance of the second order autoregression (AR2) model. ‚Äî ar2cov","text":"","code":"ar2cov(a1, a2, k = 30, useC = FALSE)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2cov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Illustrative code to compute the covariance of the second order autoregression (AR2) model. ‚Äî ar2cov","text":"a1 first auto-regression coefficient. a2 second auto-regression coefficient. k maximum lag evaluating auto-correlation. useC just test (use C code).","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2cov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Illustrative code to compute the covariance of the second order autoregression (AR2) model. ‚Äî ar2cov","text":"autocorrelation vector matrix, whenever a1 a2 scalar vector.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2cov.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Illustrative code to compute the covariance of the second order autoregression (AR2) model. ‚Äî ar2cov","text":"Let second order auto-regression model defined x_t + a_1 x_{t-1} + a_2 x_{t-2} = w_t w_t ~ N(0, 1).","code":""},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2cov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Illustrative code to compute the covariance of the second order autoregression (AR2) model. ‚Äî ar2cov","text":"","code":"ar2cov(c(-1.7, -1.8), 0.963, k = 5) #>           [,1]      [,2]       [,3]        [,4]       [,5] #> [1,] 0.8660214 0.5092364 0.03172323 -0.43646514 -0.7725402 #> [2,] 0.9169638 0.6875349 0.35452664 -0.02394815 -0.3845158 plot(ar2cov(-1.7, 0.963), type = \"o\")"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix for a stationary AR2 model. ‚Äî ar2precision","title":"Precision matrix for a stationary AR2 model. ‚Äî ar2precision","text":"Creates precision matrix sparse matrix object considering specification stated Details.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix for a stationary AR2 model. ‚Äî ar2precision","text":"","code":"ar2precision(n, a)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix for a stationary AR2 model. ‚Äî ar2precision","text":"n integer size precision matrix. numeric vector length three coefficients.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix for a stationary AR2 model. ‚Äî ar2precision","text":"sparse matrix.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2precision.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Precision matrix for a stationary AR2 model. ‚Äî ar2precision","text":"Let second order auto-regression model defined $$a_0 x_t + a_1 x_{t-1} + a_2 x_{t-2} = w_t, w_t ~ N(0, 1).$$ stationary assumption consider variance \\(x_t\\) \\(t=1,\\ldots,n\\). assumption gives \\(n \\times n\\) symmetric precision matrix \\(Q\\) sparse matrix following non-zero elements: \\(Q_{1,1} = Q_{n,n} = a_0^2\\) \\(Q_{2,2} = Q_{n-1,n-1} = a_0^2 + a_1^2\\) \\(Q_{1,2} = Q_{2,1} = Q_{n-1,n} = Q_{n,n-1} = a_0 a_1\\) \\(Q_{t,t} = q_0 = a_0^2 + a_1^2 + a_2^2, t = 3, 4, ..., n-2\\) \\(Q_{t,t-1} = Q_{t-1,t} = q_1 = a_1(a_0 + a_2), t = 3, 4, ..., n-1\\) \\(Q_{t,t-2} = Q_{t-2,t} = q_2 = a_2 a_0, t = 3, 4, ..., n\\)","code":""},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ar2precision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrix for a stationary AR2 model. ‚Äî ar2precision","text":"","code":"ar2precision(7, c(1, -1.5, 0.9)) #> 7 x 7 sparse Matrix of class \"dgTMatrix\" #>                                              #> [1,]  1.0 -1.50  0.90  .     .     .     .   #> [2,] -1.5  3.25 -2.85  0.90  .     .     .   #> [3,]  0.9 -2.85  4.06 -2.85  0.90  .     .   #> [4,]  .    0.90 -2.85  4.06 -2.85  0.90  .   #> [5,]  .    .     0.90 -2.85  4.06 -2.85  0.9 #> [6,]  .    .     .     0.90 -2.85  3.25 -1.5 #> [7,]  .    .     .     .     0.90 -1.50  1.0"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/barrierModel.define.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a spacetime model object for the f() call. ‚Äî barrierModel.define","title":"Define a spacetime model object for the f() call. ‚Äî barrierModel.define","text":"Define spacetime model object f() call.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/barrierModel.define.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a spacetime model object for the f() call. ‚Äî barrierModel.define","text":"","code":"barrierModel.define(   mesh,   barrier.triangles,   prior.range,   prior.sigma,   range.fraction = 0.1,   constr = FALSE,   debug = FALSE,   useINLAprecomp = TRUE,   libpath = NULL )"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/barrierModel.define.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a spacetime model object for the f() call. ‚Äî barrierModel.define","text":"mesh spatial mesh barrier.triangles integer vector specify triangles centers barrier domain, list integer vector one. prior.range numeric vector containing U define probability statements P(range < U) = used setup PC-prior range. = 0 = NA, U taken fixed value range. prior.sigma numeric vector containing U define probability statements P(range > U) = used setup PC-prior sigma. = 0 = NA, U taken fixed value sigma. range.fraction numeric specify fraction range barrier domain. Default value 0.1. specified care order small enough make act barrier small order prevent numerical issues. constr logical, default FALSE, indicate integral field domain constrained zero. debug integer, default zero, indicating verbose level. used logical INLA. useINLAprecomp logical, default TRUE, indicating used shared object pre-compiled INLA. considered 'libpath' provided. libpath string, default NULL, path shared object.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/barrierModel.define.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a spacetime model object for the f() call. ‚Äî barrierModel.define","text":"objects used f() formula term INLA.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/barrierModel.define.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define a spacetime model object for the f() call. ‚Äî barrierModel.define","text":"See paper.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/bru_get_mapper.stModel_cgeneric.html","id":null,"dir":"Reference","previous_headings":"","what":"Mapper object for automatic inlabru interface ‚Äî bru_get_mapper.stModel_cgeneric","title":"Mapper object for automatic inlabru interface ‚Äî bru_get_mapper.stModel_cgeneric","text":"Return inlabru bru_mapper object can used computing model matrices space-time model components.  bru_get_mapper() function called inlabru methods automatically obtain needed mapper object (inlabru 2.7.0.9001; , use mapper = bru_get_mapper(model) explicitly).","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/bru_get_mapper.stModel_cgeneric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mapper object for automatic inlabru interface ‚Äî bru_get_mapper.stModel_cgeneric","text":"","code":"# S3 method for class 'stModel_cgeneric' bru_get_mapper(model, ...)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/bru_get_mapper.stModel_cgeneric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mapper object for automatic inlabru interface ‚Äî bru_get_mapper.stModel_cgeneric","text":"model model object (class stModel_cgeneric, stModel.define barrierModel_cgeneric, barrierModel.define) ... Unused.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/bru_get_mapper.stModel_cgeneric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mapper object for automatic inlabru interface ‚Äî bru_get_mapper.stModel_cgeneric","text":"bru_mapper object class bru_mapper_multi sub-mappers space time based model smesh tmesh mesh objects.","code":""},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cWhittleMatern.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the Whittle-Matern correlation function. ‚Äî cWhittleMatern","title":"Computes the Whittle-Matern correlation function. ‚Äî cWhittleMatern","text":"computes correlation function derived Matern model, see Matern (1960) eq. (2.4.7). nu=1, see Whittle (1954) eq. (68). limiting case nu=0, see Besag (1981) eq. (14-15).","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cWhittleMatern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the Whittle-Matern correlation function. ‚Äî cWhittleMatern","text":"","code":"cWhittleMatern(x, range, nu, kappa = sqrt(8 * nu)/range)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cWhittleMatern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the Whittle-Matern correlation function. ‚Äî cWhittleMatern","text":"x distance. range practical range (prefered parametrization) given range = sqrt(8 * nu) / kappa, kappa scale parameter specialized references. nu process smoothness parameter. kappa scale parameter, commonly considered specialized literature.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cWhittleMatern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the Whittle-Matern correlation function. ‚Äî cWhittleMatern","text":"correlation.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cWhittleMatern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computes the Whittle-Matern correlation function. ‚Äî cWhittleMatern","text":"Whittle, P. (1954) Stationary Processes Plane. Biometrika, Vol. 41, . 3/4, pp. 434-449. http://www.jstor.org/stable/2332724 Matern, B. (1960) Spatial Variation: Stochastic models application problems forest surveys sampling investigations. PhD Thesis. Besag, J. (1981) System Two-Dimensional Recurrence Equations. JRSS-B, Vol. 43 . 3, pp. 302-309. https://www.jstor.org/stable/2984940","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cWhittleMatern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes the Whittle-Matern correlation function. ‚Äî cWhittleMatern","text":"","code":"plot(function(x) cWhittleMatern(x, 1, 5),   bty = \"n\", las = 1,   xlab = \"Distance\", ylab = \"Correlation\" ) plot(function(x) cWhittleMatern(x, 1, 1), add = TRUE, lty = 2) plot(function(x) cWhittleMatern(x, 1, 0.5), add = TRUE, lty = 3) abline(h = 0.139, lty = 3, col = gray(0.5, 0.5))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cgeneric_sspde.html","id":null,"dir":"Reference","previous_headings":"","what":"Define the stationary SPDE cgeneric model for INLA. ‚Äî cgeneric_sspde","title":"Define the stationary SPDE cgeneric model for INLA. ‚Äî cgeneric_sspde","text":"Define stationary SPDE cgeneric model INLA.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cgeneric_sspde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define the stationary SPDE cgeneric model for INLA. ‚Äî cgeneric_sspde","text":"","code":"cgeneric_sspde(mesh, alpha, control.priors, constr = FALSE, ...)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cgeneric_sspde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define the stationary SPDE cgeneric model for INLA. ‚Äî cgeneric_sspde","text":"mesh triangulation mesh discretize model. alpha integer used compute smoothness parameter. control.priors named list parameter priors. shall contain prange psigma one length two vector (U, ) define PC-prior parameters P(range<U)=P(sigma>U)=, respectively. See Fuglstad et. al. (2019) <DOI: 10.1080/01621459.2017.1415907>. =0 =NA, U taken fixed value parameter. constr logical, default FALSE, indicate integral field domain constrained zero. ... additional arguments passed INLAtools::cgenericBuilder(), : debug : logical/integer, default FALSE/0. useINLAprecomp logical, default TRUE, indicating used shared object pre-compiled INLA.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cgeneric_sspde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define the stationary SPDE cgeneric model for INLA. ‚Äî cgeneric_sspde","text":"objects used f() formula term INLA.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cgeneric_sspde.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Define the stationary SPDE cgeneric model for INLA. ‚Äî cgeneric_sspde","text":"stationary case INLA::inla.spde2.pcmatern() slight change marginal variance domain sphere, following Eq. (23) Lindgren et. al. (2024).","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/cgeneric_sspde.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Define the stationary SPDE cgeneric model for INLA. ‚Äî cgeneric_sspde","text":"Geir-Arne Fuglstad, Daniel Simpson, Finn Lindgren & H√•vard Rue (2019). Constructing Priors Penalize Complexity Gaussian Random Fields. Journal American Statistical Association, V. 114, Issue 525. Finn Lindgren, Haakon Bakka, David Bolin, Elias Krainski H√•vard Rue (2024). diffusion-based spatio-temporal extension Gaussian Mat√©rn fields. SORT vol.  48, . 1, pp. 3-66 <doi: 10.57645/20.8080.02.13>","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/downloadUtilFiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Download files from the NOAA's GHCN daily data ‚Äî downloadUtilFiles","title":"Download files from the NOAA's GHCN daily data ‚Äî downloadUtilFiles","text":"Download files NOAA's GHCN daily data","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/downloadUtilFiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download files from the NOAA's GHCN daily data ‚Äî downloadUtilFiles","text":"","code":"downloadUtilFiles(data.dir, year = 2022, force = FALSE)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/downloadUtilFiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download files from the NOAA's GHCN daily data ‚Äî downloadUtilFiles","text":"data.dir folder store files. year year daily weather data. force logical indicating force download. FALSE file downloaded exists locally yet.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/downloadUtilFiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download files from the NOAA's GHCN daily data ‚Äî downloadUtilFiles","text":"named character vector local file names: daily.data, stations., elevation.","code":""},{"path":[]},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ghcndSelect.html","id":null,"dir":"Reference","previous_headings":"","what":"Select data from the daily dataset ‚Äî ghcndSelect","title":"Select data from the daily dataset ‚Äî ghcndSelect","text":"Select data daily dataset","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ghcndSelect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select data from the daily dataset ‚Äî ghcndSelect","text":"","code":"ghcndSelect(   gzfile,   variable = c(\"TMIN\", \"TAVG\", \"TMAX\"),   station = NULL,   qflag = \"\",   verbose = TRUE,   astype = as.integer )"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ghcndSelect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select data from the daily dataset ‚Äî ghcndSelect","text":"gzfile local filename daily data file file. E.g. 2023.csv.gz daily GHCN data repository NCEI-NOAA, \"https://www.ncei.noaa.gov/pub/data/ghcn/daily/by_year/\". Please see references bellow. variable string variable name(s) selected station string (vector) station(s) selected qflag string quality control flag(s) verbose logical indicating progress printed astype function convert data class, default set convert data integer.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ghcndSelect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select data from the daily dataset ‚Äî ghcndSelect","text":"one variable, returns array whose dimentions days, stations, variables. one variable, returns matrix whose dimentions days, stations.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ghcndSelect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select data from the daily dataset ‚Äî ghcndSelect","text":"default selects TMIN, TAVG TMAX return integer original data also integer units 10 Celcius degrees.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ghcndSelect.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Select data from the daily dataset ‚Äî ghcndSelect","text":"can take time execute , example, data.table package available.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/ghcndSelect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Select data from the daily dataset ‚Äî ghcndSelect","text":"Menne, M., Durre, ., Vose, R., Gleason, B. Houston, T. (2012) overview global historical climatology network-daily database. Journal Atmospheric Oceanic Technology, 897‚Äì910.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh.dual.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracts the dual of a mesh object. ‚Äî mesh.dual","title":"Extracts the dual of a mesh object. ‚Äî mesh.dual","text":"Extracts dual mesh object.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh.dual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracts the dual of a mesh object. ‚Äî mesh.dual","text":"","code":"mesh.dual(   mesh,   returnclass = c(\"list\", \"sf\", \"sv\", \"SP\"),   mc.cores = getOption(\"mc.cores\", 2L) )"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh.dual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracts the dual of a mesh object. ‚Äî mesh.dual","text":"mesh 2d mesh object. returnclass 'list' return list polygon coordinates, \"sf\" return 'sf' sfc_multipolygon object, \"sv\" return 'terra', SpatVector object, \"SP\" return 'sp' SpatialPolygons object. mc.cores number threads used.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh.dual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracts the dual of a mesh object. ‚Äî mesh.dual","text":"one three 'returnclass'","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Illustrative code for building a mesh in 2d domain. ‚Äî mesh2d","title":"Illustrative code for building a mesh in 2d domain. ‚Äî mesh2d","text":"Creates mesh object. just test code. efficient, reliable general code use fmesher package.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Illustrative code for building a mesh in 2d domain. ‚Äî mesh2d","text":"","code":"mesh2d(loc, domain, max.edge, offset, SP = TRUE)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Illustrative code for building a mesh in 2d domain. ‚Äî mesh2d","text":"loc two column matrix location coordinates. domain two column matrix defining domain. max.edge maximum edge length. offset length outer extension. SP logical indicating output include SpatialPolygons.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Illustrative code for building a mesh in 2d domain. ‚Äî mesh2d","text":"mesh object.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2d.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Illustrative code for building a mesh in 2d domain. ‚Äî mesh2d","text":"just illustration purposes one consider efficient function fmesher::fm_mesh_2d() (related functions) available fmesher package.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2fem.html","id":null,"dir":"Reference","previous_headings":"","what":"Illustrative code for Finite Element matrices of a mesh in 2d domain. ‚Äî mesh2fem","title":"Illustrative code for Finite Element matrices of a mesh in 2d domain. ‚Äî mesh2fem","text":"Illustrative code Finite Element matrices mesh 2d domain. Illustrative code Finite Element matrices triangles barrier domain.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2fem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Illustrative code for Finite Element matrices of a mesh in 2d domain. ‚Äî mesh2fem","text":"","code":"mesh2fem(mesh, order = 2, barrier.triangles = NULL)  mesh2fem.barrier(mesh, barrier.triangles = NULL)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2fem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Illustrative code for Finite Element matrices of a mesh in 2d domain. ‚Äî mesh2fem","text":"mesh 2d mesh object. order desired order. barrier.triangles integer index specify triangles barrier domain","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2fem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Illustrative code for Finite Element matrices of a mesh in 2d domain. ‚Äî mesh2fem","text":"list object containing FE matrices. list object containing FE matrices barrier problem.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Illustrative code to build the projector matrix for SPDE models. ‚Äî mesh2projector","title":"Illustrative code to build the projector matrix for SPDE models. ‚Äî mesh2projector","text":"Creates projector matrix object.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Illustrative code to build the projector matrix for SPDE models. ‚Äî mesh2projector","text":"","code":"mesh2projector(   mesh,   loc = NULL,   lattice = NULL,   xlim = NULL,   ylim = NULL,   dims = c(100, 100) )"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Illustrative code to build the projector matrix for SPDE models. ‚Äî mesh2projector","text":"mesh 2d mesh object. loc two columns matrix locations project . lattice Unused; feature supported illustration. xlim, ylim vector boundary limits. dims number subdivisions boundary limits.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Illustrative code to build the projector matrix for SPDE models. ‚Äî mesh2projector","text":"projector matrix list sparse matrix object x$proj$..","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/mesh2projector.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Illustrative code to build the projector matrix for SPDE models. ‚Äî mesh2projector","text":"just illustration purpose one consider efficient functions available fmesher package, e.g. fmesher::fm_evaluator() fmesher::fm_basis().","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/outDetect.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect outliers in a time series considering the raw data and a smoothed version of it. ‚Äî outDetect","title":"Detect outliers in a time series considering the raw data and a smoothed version of it. ‚Äî outDetect","text":"Detect outliers time series considering raw data smoothed version .","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/outDetect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect outliers in a time series considering the raw data and a smoothed version of it. ‚Äî outDetect","text":"","code":"outDetect(x, weights = NULL, ff = c(7, 7))"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/outDetect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect outliers in a time series considering the raw data and a smoothed version of it. ‚Äî outDetect","text":"x numeric vector weights non-increasing numeric vector used weights computing smoothed vector rooling window average. Default null \\(w_j\\) proportional j equation Details . ff numeric length two vector factors used consider many times standard deviation one data point considered outlier.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/outDetect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect outliers in a time series considering the raw data and a smoothed version of it. ‚Äî outDetect","text":"logical vector indicating data outlier attributes detailed bellow. attr(, 'm') mean x. attr(, 's') standard devation x. attr(, 'ss') standard deviation smoothed data \\(y_t\\) defined \\(y_t = \\sum_{k=j}^h w_j * (x_{t-j}+x_{t+j})/2\\) s ss used define outliers \\(|x_t-m|/s>ff_1\\) \\(|x_t-y_t|/ss>ff_2\\) attr(, 'xs') smoothed time series \\(y_t\\)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/paramsUtils.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions to help converting from/to user/internal parametrization. The internal parameters are 'gamma_s, 'gamma_t', 'gamma_E' The user parameters are 'r_s', 'r_t', 'sigma' ‚Äî paramsUtils","title":"Functions to help converting from/to user/internal parametrization. The internal parameters are 'gamma_s, 'gamma_t', 'gamma_E' The user parameters are 'r_s', 'r_t', 'sigma' ‚Äî paramsUtils","text":"Functions help converting /user/internal parametrization. internal parameters 'gamma_s, 'gamma_t', 'gamma_E' user parameters 'r_s', 'r_t', 'sigma' Convert user parameters SPDE parameters Convert SPDE parameters user parameters","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/paramsUtils.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions to help converting from/to user/internal parametrization. The internal parameters are 'gamma_s, 'gamma_t', 'gamma_E' The user parameters are 'r_s', 'r_t', 'sigma' ‚Äî paramsUtils","text":"","code":"lgsConstant(lg.s, alpha, smanifold)  params2gammas(   lparams,   alpha.t,   alpha.s,   alpha.e,   smanifold = \"R2\",   verbose = FALSE )  gammas2params(lgammas, alpha.t, alpha.s, alpha.e, smanifold = \"R2\")"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/paramsUtils.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions to help converting from/to user/internal parametrization. The internal parameters are 'gamma_s, 'gamma_t', 'gamma_E' The user parameters are 'r_s', 'r_t', 'sigma' ‚Äî paramsUtils","text":"lg.s logarithm SPDE parameter \\gamma_s alpha resulting spatial order. smanifold spatial domain manifold, \"S1\", \"S2\", \"R1\", \"R2\" \"R3\". lparams log(spatial range, temporal range, sigma) alpha.t temporal order SPDE alpha.s spatial order spatial differential operator non-separable part. alpha.e spatial order spatial differential operator separable part. verbose logical print internal variables lgammas numeric length 3 \\(log(\\gamma_k)\\) model parameters. parameter order log(gamma.s, gamma.t, gamma.e)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/paramsUtils.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions to help converting from/to user/internal parametrization. The internal parameters are 'gamma_s, 'gamma_t', 'gamma_E' The user parameters are 'r_s', 'r_t', 'sigma' ‚Äî paramsUtils","text":"part sigma spatial constant \\gamma_s. log(gamma.s, gamma.t, gamma.e) log(spatial range, temporal range, sigma)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/paramsUtils.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions to help converting from/to user/internal parametrization. The internal parameters are 'gamma_s, 'gamma_t', 'gamma_E' The user parameters are 'r_s', 'r_t', 'sigma' ‚Äî paramsUtils","text":"See equation (23) paper. See equations (19), (20) (21) paper. See equations (19), (20) (21) paper.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/paramsUtils.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functions to help converting from/to user/internal parametrization. The internal parameters are 'gamma_s, 'gamma_t', 'gamma_E' The user parameters are 'r_s', 'r_t', 'sigma' ‚Äî paramsUtils","text":"","code":"params2gammas(log(c(1, 1, 1)), 1, 2, 1, \"R2\") #>   gamma.s   gamma.t   gamma.e  #>  1.039721  1.386294 -3.344954  gammas2params(log(c(0, 0, 0)), 1, 2, 1, \"R2\") #>    lrs    lrt lsigma  #>    Inf    NaN    Inf"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/polyUtils.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal util functions for polygon properties. ‚Äî Heron","title":"Internal util functions for polygon properties. ‚Äî Heron","text":"computes area triangle given three coordinates.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/polyUtils.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal util functions for polygon properties. ‚Äî Heron","text":"","code":"Heron(x, y)  Area(x, y)  s2trArea(tr, R = 1)  flatArea(tr)  Stiffness(tr)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/polyUtils.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal util functions for polygon properties. ‚Äî Heron","text":"x, y coordinate vectors. tr triangle coordinates R radius spherical domain","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/polyUtils.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal util functions for polygon properties. ‚Äî Heron","text":"area 2d triangle area 2d polygon area triangle S2 area triangle stiffness matrix triangle","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/polyUtils.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Internal util functions for polygon properties. ‚Äî Heron","text":"Function used internally compute area triangle.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/polyUtils.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Internal util functions for polygon properties. ‚Äî Heron","text":"Internal functions, exported.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/spde2precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Illustrative code to build the precision matrix for SPDE kind models. ‚Äî spde2precision","title":"Illustrative code to build the precision matrix for SPDE kind models. ‚Äî spde2precision","text":"Creates precision matrix sparse matrix object. general code look functions INLA package.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/spde2precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Illustrative code to build the precision matrix for SPDE kind models. ‚Äî spde2precision","text":"","code":"spde2precision(kappa, fem, alpha)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/spde2precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Illustrative code to build the precision matrix for SPDE kind models. ‚Äî spde2precision","text":"kappa scale parameter. fem list containing Finite Element matrices. alpha smoothness parameter.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/spde2precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Illustrative code to build the precision matrix for SPDE kind models. ‚Äî spde2precision","text":"precision matrix sparse matrix object.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/spde2precision.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Illustrative code to build the precision matrix for SPDE kind models. ‚Äî spde2precision","text":"just illustration purpose one consider efficient function available INLA package.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.define.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a spacetime model object for the f() call. ‚Äî stModel.define","title":"Define a spacetime model object for the f() call. ‚Äî stModel.define","text":"Define spacetime model object f() call.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.define.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a spacetime model object for the f() call. ‚Äî stModel.define","text":"","code":"stModel.define(   smesh,   tmesh,   model,   control.priors,   constr = FALSE,   debug = FALSE,   useINLAprecomp = TRUE,   libpath = NULL )"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.define.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a spacetime model object for the f() call. ‚Äî stModel.define","text":"smesh spatial mesh tmesh temporal mesh model three characters string specify smoothness alpha (one integer) parameters. Currently considers 102, 121, 202 220 models. control.priors named list parameter priors, named prs, prt psigma, one vector length two containing (U, ) define corresponding PC-prior , respectively, P(range.spatial<U)=, P(range.temporal<U)=P(sigma>U)=. =0 =NA, U taken fixed value parameter. constr logical, default FALSE, indicate integral field domain constrained zero. debug integer, default zero, indicating verbose level. used logical INLA. useINLAprecomp logical, default TRUE, indicating used shared object pre-compiled INLA. considered 'libpath' provided. libpath string, default NULL, path shared object.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.define.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a spacetime model object for the f() call. ‚Äî stModel.define","text":"objects used f() formula term INLA.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.define.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define a spacetime model object for the f() call. ‚Äî stModel.define","text":"function compute matrices computing precision matrix. one Kronecker products Theorem 4.1 Lindgren et. al. (2024) computed stModel.matrices parameters Eq (19-21). use log parameters internally.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.define.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Define a spacetime model object for the f() call. ‚Äî stModel.define","text":"Finn Lindgren, Haakon Bakka, David Bolin, Elias Krainski H√•vard Rue (2024). diffusion-based spatio-temporal extension Gaussian Mat√©rn fields. SORT vol.  48, . 1, pp. 3-66 <doi: 10.57645/20.8080.02.13>","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.matrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Define the spacetime model matrices. ‚Äî stModel.matrices","title":"Define the spacetime model matrices. ‚Äî stModel.matrices","text":"function computes matrices needed build precision matrix spatio-temporal model, Lindgren et. al. (2024)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.matrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define the spacetime model matrices. ‚Äî stModel.matrices","text":"","code":"stModel.matrices(smesh, tmesh, model, constr = FALSE)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.matrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define the spacetime model matrices. ‚Äî stModel.matrices","text":"smesh mesh object spatial domain. tmesh mesh object time domain. model string identifying model. far following models: '102', '121', '202' '220' models. constr logical indicate integral field domain constrained zero. Default value FALSE.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.matrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define the spacetime model matrices. ‚Äî stModel.matrices","text":"list containing needed objects model definition. 'manifold' spedify string model identification length three vector constants c1, c2 c3 vector d matrix T model matrices M_1, ..., M_m","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.matrices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define the spacetime model matrices. ‚Äî stModel.matrices","text":"See paper details.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Spacetime precision matrix. ‚Äî stModel.precision","title":"Spacetime precision matrix. ‚Äî stModel.precision","text":"build precision matrix spacetime model given temporal spatial meshes.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spacetime precision matrix. ‚Äî stModel.precision","text":"","code":"stModel.precision(smesh, tmesh, model, theta, verbose = FALSE)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spacetime precision matrix. ‚Äî stModel.precision","text":"smesh mesh object spatial domain. tmesh mesh object time domain. model string identifying model. far following models: '102', '121', '202' '220' models. theta numeric vector length three \\(log(gamma_s, gamma_t, gamma_e)\\). verbose logical print intermediate objects.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stModel.precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spacetime precision matrix. ‚Äî stModel.precision","text":"(sparse) precision matrix, Lindgren et. al. (2024)","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stats.inla.html","id":null,"dir":"Reference","previous_headings":"","what":"To retrieve goodness of fit statistics for a specific model class. ‚Äî stats.inla","title":"To retrieve goodness of fit statistics for a specific model class. ‚Äî stats.inla","text":"Extracts dic, waic log-cpo output returned inla function INLA package bru function inlabru package, computes log-po, mse, mae, crps scrps given input. summary applied considering user imputed function, default mean.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stats.inla.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"To retrieve goodness of fit statistics for a specific model class. ‚Äî stats.inla","text":"","code":"stats.inla(m, i = NULL, y, fsummarize = mean)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stats.inla.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"To retrieve goodness of fit statistics for a specific model class. ‚Äî stats.inla","text":"m inla output object. index subset estimated values. y observed compare . fsummarize summary function, default base::mean().","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stats.inla.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"To retrieve goodness of fit statistics for a specific model class. ‚Äî stats.inla","text":"named numeric vector extracted statistics.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stats.inla.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"To retrieve goodness of fit statistics for a specific model class. ‚Äî stats.inla","text":"assumes Gaussian posterior predictive distributions! Considering defaults, n observations, \\(y_i, = 1, 2, ..., n\\), . dic $$\\sum_i d_i/n$$ \\(d_i\\) dic computed observation . . waic $$\\sum_i w_i/n$$ \\(w_i\\) waic computed observation . . lcpo $$-\\sum_i \\log(p_i)/n$$ \\(p_i\\) cpo computed observation . log-po, crps, scrps scores assumes Gaussian predictive distribution observation \\(y_i\\) following definitions: \\(z_i = (y_i-\\mu_i)/\\sigma_i\\), \\(\\mu_i\\) posterior mean linear predictor, \\(\\sigma_i = \\sqrt{v_i + 1/\\tau_y}\\), \\(\\tau_y\\) observation posterior mean, \\(v_i\\) posterior variance linear predictor \\(y_i\\). consider \\(\\phi()\\) density standard Gaussian variable \\(\\psi()\\) corresponding Cumulative Probability Distribution. . lpo $$-\\sum_i \\log(\\phi(z_i))/n$$ . crps $$\\sum_i r_i/n$$ $$r_i=\\sigma_i/\\sqrt{\\pi} - 2\\sigma_i\\phi(z_i) + (y_i-\\mu_i)(1-2\\psi(z_i))$$ . scrps $$\\sum_i s_i/n$$ $$s_i=-\\log(2\\sigma_i/\\sqrt{\\pi})/2 -\\sqrt{\\pi}(\\phi(z_i)-\\sigma_iz_i/2+z_i\\psi(z_i))$$","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stats.inla.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"To retrieve goodness of fit statistics for a specific model class. ‚Äî stats.inla","text":"scores negatively oriented means smaller scores better.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stats.inla.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"To retrieve goodness of fit statistics for a specific model class. ‚Äî stats.inla","text":"Held, L. Schr√∂dle, B. Rue, H. (2009). Posterior Cross-validatory Predictive Checks: Comparison MCMC INLA. Statistical Modelling Regression Structures pp 91‚Äì110. https://link.springer.com/chapter/10.1007/978-3-7908-2413-1_6. Bolin, D. Wallin, J. (2022) Local scale invariance robustness proper scoring rules. Statistical Science. doi:10.1214/22-STS864 .","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stdSubs.html","id":null,"dir":"Reference","previous_headings":"","what":"To check unusual low/high variance segments ‚Äî stdSubs","title":"To check unusual low/high variance segments ‚Äî stdSubs","text":"check unusual low/high variance segments","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stdSubs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"To check unusual low/high variance segments ‚Äî stdSubs","text":"","code":"stdSubs(x, nsub = 12, fs = 15)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stdSubs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"To check unusual low/high variance segments ‚Äî stdSubs","text":"x numeric vector nsub number segments length fs numeric use detecting hight low local standard deviations.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/stdSubs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"To check unusual low/high variance segments ‚Äî stdSubs","text":"logical indicating st fs times lower/higher average st, returned attribute: attr(, 'st') numeric vector standard deviation segment data.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/worldMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper functions to retrieve the world map, a world polygon, and create grid centers. ‚Äî worldMap","title":"Helper functions to retrieve the world map, a world polygon, and create grid centers. ‚Äî worldMap","text":"Retrieve map countries","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/worldMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper functions to retrieve the world map, a world polygon, and create grid centers. ‚Äî worldMap","text":"","code":"worldMap(   crs = \"+proj=moll +units=km\",   scale = \"medium\",   returnclass = c(\"sf\", \"sv\") )"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/worldMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper functions to retrieve the world map, a world polygon, and create grid centers. ‚Äî worldMap","text":"crs string projection. Default Mollweide projection units kilometers. scale scale map return. Please see help 'ne_countries' function 'rnaturalearth' package. returnclass string determining class spatial object return. Please see help 'ne_countries' function 'rnaturalearth' package.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/worldMap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Helper functions to retrieve the world map, a world polygon, and create grid centers. ‚Äî worldMap","text":"land ocean maps obtained 'rnaturalearth' package.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/world_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a regular grid in 'Mollweide' projection, with units in kilometers. ‚Äî world_grid","title":"Define a regular grid in 'Mollweide' projection, with units in kilometers. ‚Äî world_grid","text":"Define regular grid 'Mollweide' projection, units kilometers.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/world_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a regular grid in 'Mollweide' projection, with units in kilometers. ‚Äî world_grid","text":"","code":"world_grid(size = 50, domain)"},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/world_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a regular grid in 'Mollweide' projection, with units in kilometers. ‚Äî world_grid","text":"size (kilometers) grid cells. domain provided sf sfc object. case, grid cells centers falling inside retrieved.","code":""},{"path":"https://eliaskrainski.github.io/INLAspacetime/reference/world_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a regular grid in 'Mollweide' projection, with units in kilometers. ‚Äî world_grid","text":"'sf' points object centers grid set within Earth (supplied domain)","code":""}]
